/* file "alpha.data" */

/*  Copyright (c) 1994 Stanford University

    All rights reserved.

    Copyright (c) 1996 The President and Fellows of Harvard University

    All rights reserved.

    This software is provided under the terms described in
    the "suif_copyright.h" include file. */

#include <suif_copyright.h>

/*
 * Complete listing of the ALPHA assembly opcodes, pseudo-ops, and
 * opcode extensions, and the code generator/schedulers pseudo-ops.
 *
 * To ensure alignment, this table collects all data about
 * each opcode.  To use it, redefine the "xx" macro to format
 * the appropriate fields.  Then include this file in your
 * source file.
 */

#ifndef xx
#define xx(opcode, string, format)
#endif

/** Null (mif_xx) instruction */
xx(ao_null,		"",		mif_xx)	/* null instr for comments */

/** Label (mif_lab) "opcode" */
xx(ao_lab,		"",		mif_lab)

/** Pseudo-opcode (mif_xx) instructions */
xx(ao_aent,		".aent",	mif_xx)	/* alternative entry point */
xx(ao_alias,		".alias",	mif_xx)	/* two registers alias (at least partially) */
xx(ao_align,		".align",	mif_xx)	/* align location counter */
xx(ao_ascii,		".ascii",	mif_xx)	/* assemble strings into successive locs */
xx(ao_asciiz,		".asciiz",	mif_xx)	/* assemble strings and add null */
xx(ao_bgnb,		".bgnb",	mif_xx)	/* begin language block */
xx(ao_byte,		".byte",	mif_xx)	/* assemble expressions into succ. bytes */
xx(ao_comm,		".comm",	mif_xx)	/* global common symbol */
xx(ao_data,		".data",	mif_xx)	/* subsequent data to data section */
xx(ao_d_floating,	".d_floating",	mif_xx)	/* initializes 64-bit VAX D_floating numbers */
xx(ao_double,		".double",	mif_xx)	/* initializes 64-bit FP numbers */
xx(ao_edata,		".edata",	mif_xx)	/* exception handling data */
xx(ao_eflag,		".eflag",	mif_xx)	/* exception related flags */
xx(ao_end,		".end",		mif_xx)	/* end of procedure */
xx(ao_endb,		".endb",	mif_xx)	/* end of language block */
xx(ao_endr,		".endr",	mif_xx)	/* end of repeat */
xx(ao_ent,		".ent",		mif_xx)	/* beginning of procedure */
xx(ao_err,		".err",		mif_xx)	/* error in front end */
xx(ao_extended,		".extended",	mif_xx)	/* synonym for .x_floating */
xx(ao_extern,		".extern",	mif_xx)	/* global undefined symbol */
xx(ao_f_floating,	".f_floating",	mif_xx)	/* initializes 32-bit VAX F_floating numbers */
xx(ao_file,		".file",	mif_xx)	/* source file name */
xx(ao_float,		".float",	mif_xx)	/* synonym for .s_floating */
xx(ao_fmask,		".fmask",	mif_xx)	/* FP registers saved */
xx(ao_fnop,		"fnop",		mif_xx)	/* FP nop */
xx(ao_frame,		".frame",	mif_xx)	/* describes the stack frame */
xx(ao_g_floating,	".g_floating",	mif_xx)	/* initializes 64-bit VAX G_floating numbers */
xx(ao_gjsrlive,		".gjsrlive",	mif_xx)	/* sets masks for live regs before call */
xx(ao_gjsrsaved,	".gjsrsaved",	mif_xx)	/* sets masks for preserved regs before call */
xx(ao_globl,		".globl",	mif_xx)	/* makes a name external */
xx(ao_gprel32,		".gprel32",	mif_xx)	/* truncates signed displacement to 32-bits */
xx(ao_gretlive,		".gretlive",	mif_xx)	/* sets masks for live regs before return */
xx(ao_dotlab,		".lab",		mif_xx)	/* associates label with current location */
xx(ao_lcomm,		".lcomm",	mif_xx)	/* makes name's data type bss */
xx(ao_livereg,		".livereg",	mif_xx)	/* regs live before jump */
xx(ao_loc,		".loc",		mif_xx)	/* specifies source and line number */
xx(ao_long,		".long",	mif_xx)	/* truncates values to 32 bits */
xx(ao_mask,		".mask",	mif_xx)	/* GP registers saved */
xx(ao_noalias,		".noalias",	mif_xx)	/* two registers do not alias */
xx(ao_nop,		"nop",		mif_xx)	/* nop */
xx(ao_option,		".option",	mif_xx)	/* options in effect during compilation */
xx(ao_prologue,		".prologue",	mif_xx)	/* end of proc prologue */
xx(ao_quad,		".quad",	mif_xx)	/* trancates values to 64 bits */
xx(ao_rdata,		".rdata",	mif_xx)	/* subsequent data to rdata section */
xx(ao_repeat,		".repeat",	mif_xx)	/* begin repeat directive */
xx(ao_save_ra,		".save_ra",	mif_xx)	/* register containing return address */
xx(ao_sdata,		".sdata",	mif_xx)	/* subsequent data to sdata section */
xx(ao_set,		".set",		mif_xx)	/* set assembler options */
xx(ao_s_floating,	".s_floating",	mif_xx)	/* initializes 32-bit IEEE FP numbers */
xx(ao_space,		".space",	mif_xx)	/* fill with 0's */
xx(ao_struct,		".struct",	mif_xx)	/* layout a structure using labels */
xx(ao_text,		".text",	mif_xx)	/* subsequent code to text section */
xx(ao_t_floating,	".t_floating",	mif_xx)	/* initializes 64-bit IEEE FP numbers */
xx(ao_ugen,		".ugen",	mif_xx)	/* source generated by code generator */
xx(ao_unop,		"unop",		mif_xx)	/* universal nop */
xx(ao_verstamp,		".verstamp",	mif_xx)	/* major and minor version numbers */
xx(ao_vreg,		".vreg",	mif_xx)	/* register variable description */
xx(ao_weakext,		".weakext",	mif_xx)	/* weak symbol during linking */
xx(ao_word,		".word",	mif_xx)	/* truncates values to 16 bits */
xx(ao_x_floating,	".x_floating",	mif_xx)	/* initializes 128-bit IEEE FP numbers */
    
/** Load immediate (mif_rr) instructions */
xx(ao_ldil,		"ldil",		mif_rr)	/* load immediate longword */
xx(ao_ldiq,		"ldiq",		mif_rr)	/* load immediate quadword */

/** Load (mif_rr) instructions */
xx(ao_lda,		"lda",		mif_rr)	/* load address */
xx(ao_ldah,		"ldah",		mif_rr)	/* load adr high, b+o only */
xx(ao_ldgp,		"ldgp",		mif_rr)	/* load global ptr, b+o only */
xx(ao_ldb,		"ldb",		mif_rr)	/* load byte */
xx(ao_ldbu,		"ldbu",		mif_rr)	/* load byte unsigned */
xx(ao_ldw,		"ldw",		mif_rr)	/* load word (16 bits) */
xx(ao_ldwu,		"ldwu",		mif_rr)	/* load word unsigned */
xx(ao_ldl,		"ldl",		mif_rr)	/* load sign-ext longword (32b) */
/* ao_ldlu does not exist in Alpha because it is not needed */
xx(ao_ldl_l,		"ldl_l",	mif_rr)	/* load sign-ext longword locked */
xx(ao_ldq,		"ldq",		mif_rr)	/* load quadword (64 bits) */
xx(ao_ldq_l,		"ldq_l",	mif_rr)	/* load quadword locked */
xx(ao_ldq_u,		"ldq_u",	mif_rr)	/* load quadword unaligned */
xx(ao_uldw,		"uldw",		mif_rr)	/* unaligned load word */
xx(ao_uldwu,		"uldwu",	mif_rr)	/* unaligned load word unsigned */
xx(ao_uldl,		"uldl",		mif_rr)	/* unaligned load longword */
xx(ao_uldq,		"uldq",		mif_rr)	/* unaligned load quadword */

xx(ao_cg_lrec,		"cg_lrec",	mif_rr)	/* load record for 1st pass of code gen */

/** Store (mif_rr) instructions */
xx(ao_stb,		"stb",		mif_rr)	/* store byte */
xx(ao_stw,		"stw",		mif_rr)	/* store word (16 bits) */
xx(ao_stl,		"stl",		mif_rr)	/* store longword (32 bits) */
xx(ao_stl_c,		"stl_c",	mif_rr)	/* store longword cond'l */
xx(ao_stq,		"stq",		mif_rr)	/* store quadword (64 bits) */
xx(ao_stq_c,		"stq_c",	mif_rr)	/* store quadword cond'l */
xx(ao_stq_u,		"stq_u",	mif_rr)	/* store quadword unaligned */
xx(ao_ustw,		"ustw",		mif_rr)	/* unaligned store word */
xx(ao_ustl,		"ustl",		mif_rr)	/* unaligned store longword */
xx(ao_ustq,		"ustq",		mif_rr)	/* unaligned store quadword */

xx(ao_cg_srec,		"cg_srec",	mif_rr)	/* store record for 1st pass of code gen */

/** General computational (mif_rr) instructions */
xx(ao_absl,		"absl",		mif_rr)	/* absolute value */
xx(ao_absq,		"absq",		mif_rr)	/* absolute value */
xx(ao_addl,		"addl",		mif_rr)	/* add longword (no overflow) */
xx(ao_addlv,		"addlv",	mif_rr)	/* add longword (overflow) */
xx(ao_addq,		"addq",		mif_rr)	/* add quadword (no overflow) */
xx(ao_addqv,		"addqv",	mif_rr)	/* add quadword (overflow) */
xx(ao_and,		"and",		mif_rr)	/* and */
xx(ao_andnot,		"andnot",	mif_rr)	/* logical product with complement (andnot) */
xx(ao_bic,		"bic",		mif_rr)	/* logical product with complement (andnot) */
xx(ao_bis,		"bis",		mif_rr)	/* logical sum (or) */
xx(ao_clr,		"clr",		mif_rr)	/* clear */
xx(ao_cmoveq,		"cmoveq",	mif_rr)	/* move if equal to zero */
xx(ao_cmovne,		"cmovne",	mif_rr)	/* move if not equal to zero */
xx(ao_cmovlt,		"cmovlt",	mif_rr)	/* move if < zero */
xx(ao_cmovle,		"cmovle",	mif_rr)	/* move if <= zero */
xx(ao_cmovgt,		"cmovgt",	mif_rr)	/* move if > zero */
xx(ao_cmovge,		"cmovge",	mif_rr)	/* move if >= zero */
xx(ao_cmovlbc,		"cmovlbc",	mif_rr)	/* move if low bit clear */
xx(ao_cmovlbs,		"cmovlbs",	mif_rr)	/* move if low bit set */
xx(ao_cmpeq,		"cmpeq",	mif_rr)	/* compare signed quadword equal */
xx(ao_cmplt,		"cmplt",	mif_rr)	/* compare signed quadword < */
xx(ao_cmple,		"cmple",	mif_rr)	/* compare signed quadword <= */
xx(ao_cmpult,		"cmpult",	mif_rr)	/* compare unsigned quadword < */
xx(ao_cmpule,		"cmpule",	mif_rr)	/* compare unsigned quadword <= */
xx(ao_divl,		"divl",		mif_rr)	/* divide longword */
xx(ao_divlu,		"divlu",	mif_rr)	/* divide longword unsigned */
xx(ao_divq,		"divq",		mif_rr)	/* divide quadword */
xx(ao_divqu,		"divqu",	mif_rr)	/* divide quadword unsigned */
xx(ao_eqv,		"eqv",		mif_rr)	/* logical equivalence (xornot) */
xx(ao_mov,		"mov",		mif_rr)	/* move */
xx(ao_mull,		"mull",		mif_rr)	/* multiply longword (no overflow) */
xx(ao_mullv,		"mullv",	mif_rr)	/* multiply longword (overflow) */
xx(ao_mulq,		"mulq",		mif_rr)	/* multiply quadword (no overflow) */
xx(ao_mulqv,		"mulqv",	mif_rr)	/* multiply quadword (overflow) */
xx(ao_negl,		"negl",		mif_rr)	/* negate longword (no overflow) */
xx(ao_neglv,		"neglv",	mif_rr)	/* negate longword (overflow) */
xx(ao_negq,		"negq",		mif_rr)	/* negate quadword (no overflow) */
xx(ao_negqv,		"negqv",	mif_rr)	/* negate quadword (overflow) */
xx(ao_not,		"not",		mif_rr)	/* not */
xx(ao_or,		"or",		mif_rr)	/* or */
xx(ao_ornot,		"ornot",	mif_rr)	/* logical sum with complement (andnot) */
xx(ao_reml,		"reml",		mif_rr)	/* longword remainder */
xx(ao_remlu,		"remlu",	mif_rr)	/* longword remainder unsigned */
xx(ao_remq,		"remq",		mif_rr)	/* quadword remainder */
xx(ao_remqu,		"remqu",	mif_rr)	/* quadword remainder unsigned */
xx(ao_s4addl,		"s4addl",	mif_rr)	/* scaled longword add by 4 */
xx(ao_s4addq,		"s4addq",	mif_rr)	/* scaled quadword add by 4 */
xx(ao_s8addl,		"s8addl",	mif_rr)	/* scaled longword add by 8 */
xx(ao_s8addq,		"s8addq",	mif_rr)	/* scaled quadword add by 8 */
xx(ao_s4subl,		"s4subl",	mif_rr)	/* scaled longword subtract by 4 */
xx(ao_s4subq,		"s4subq",	mif_rr)	/* scaled quadword subtract by 4 */
xx(ao_s8subl,		"s8subl",	mif_rr)	/* scaled longword subtract by 8 */
xx(ao_s8subq,		"s8subq",	mif_rr)	/* scaled quadword subtract by 8 */
xx(ao_setxl,		"setxl",	mif_rr)	/* sign-extend longword */
xx(ao_sll,		"sll",		mif_rr)	/* shift left logical */
xx(ao_sra,		"sra",		mif_rr)	/* shift right arithmetic */
xx(ao_srl,		"srl",		mif_rr)	/* shift right logical */
xx(ao_subl,		"subl",		mif_rr)	/* subtract longword (no overflow) */
xx(ao_sublv,		"sublv",	mif_rr)	/* subtract longword (overflow) */
xx(ao_subq,		"subq",		mif_rr)	/* subtract quadword (no overflow) */
xx(ao_subqv,		"subqv",	mif_rr)	/* subtract quadword (overflow) */
xx(ao_umulh,		"umulh",	mif_rr)	/* unsigned quadword multiply high */
xx(ao_xor,		"xor",		mif_rr)	/* exclusive or (logical difference) */
xx(ao_xornot,		"xornot",	mif_rr)	/* logical equivalence (xornot) */

/** Byte-manipulation (mif_rr) instructions */
xx(ao_cmpbge,		"cmpbge",	mif_rr)	/* compare byte */
xx(ao_extbl,		"extbl",	mif_rr)	/* extract byte low */
xx(ao_extwl,		"extwl",	mif_rr)	/* extract word low */
xx(ao_extll,		"extll",	mif_rr)	/* extract longword low */
xx(ao_extql,		"extql",	mif_rr)	/* extract quadword low */
xx(ao_extwh,		"extwh",	mif_rr)	/* extract word high */
xx(ao_extlh,		"extlh",	mif_rr)	/* extract longword high */
xx(ao_extqh,		"extqh",	mif_rr)	/* extract quadword high */
xx(ao_insbl,		"insbl",	mif_rr)	/* insert byte low */
xx(ao_inswl,		"inswl",	mif_rr)	/* insert word low */
xx(ao_insll,		"insll",	mif_rr)	/* insert longword low */
xx(ao_insql,		"insql",	mif_rr)	/* insert quadword low */
xx(ao_inswh,		"inswh",	mif_rr)	/* insert word high */
xx(ao_inslh,		"inslh",	mif_rr)	/* insert longword high */
xx(ao_insqh,		"insqh",	mif_rr)	/* insert quadword high */
xx(ao_mskbl,		"mskbl",	mif_rr)	/* mask byte low */
xx(ao_mskwl,		"mskwl",	mif_rr)	/* mask word low */
xx(ao_mskll,		"mskll",	mif_rr)	/* mask longword low */
xx(ao_mskql,		"mskql",	mif_rr)	/* mask quadword low */
xx(ao_mskwh,		"mskwh",	mif_rr)	/* mask word high */
xx(ao_msklh,		"msklh",	mif_rr)	/* mask longword high */
xx(ao_mskqh,		"mskqh",	mif_rr)	/* mask quadword high */
xx(ao_zap,		"zap",		mif_rr)	/* zero bytes */
xx(ao_zapnot,		"zapnot",	mif_rr)	/* zero bytes not */

/** Branch (mif_bj) instructions */
xx(ao_br,		"br",		mif_bj)	/* branch */
xx(ao_beq,		"beq",		mif_bj)	/* branch on equal */
xx(ao_beq_N,		"beq_N",	mif_bj)	/* branch on equal [predict not taken] */
xx(ao_beq_T,		"beq_T",	mif_bj)	/* branch on equal [predict taken] */
xx(ao_bge,		"bge",		mif_bj)	/* branch >= */
xx(ao_bge_N,		"bge_N",	mif_bj)	/* branch >= [predict not taken] */
xx(ao_bge_T,		"bge_T",	mif_bj)	/* branch >= [predict taken] */
xx(ao_bgt,		"bgt",		mif_bj)	/* branch > */
xx(ao_bgt_N,		"bgt_N",	mif_bj)	/* branch > [predict not taken] */
xx(ao_bgt_T,		"bgt_T",	mif_bj)	/* branch > [predict taken] */
xx(ao_blbc,		"blbc",		mif_bj)	/* branch if low bit is clear */
xx(ao_blbc_N,		"blbc_N",	mif_bj)	/* branch if low bit clear [predicted] */
xx(ao_blbc_T,		"blbc_T",	mif_bj)	/* branch if low bit clear [predicted] */
xx(ao_blbs,		"blbs",		mif_bj)	/* branch if low bit is set */
xx(ao_blbs_N,		"blbs_N",	mif_bj)	/* branch if low bit set [predicted] */
xx(ao_blbs_T,		"blbs_T",	mif_bj)	/* branch if low bit set [predicted] */
xx(ao_ble,		"ble",		mif_bj)	/* branch <= */
xx(ao_ble_N,		"ble_N",	mif_bj)	/* branch <= [predicted] */
xx(ao_ble_T,		"ble_T",	mif_bj)	/* branch <= [predicted] */
xx(ao_blt,		"blt",		mif_bj)	/* branch < */
xx(ao_blt_N,		"blt_N",	mif_bj)	/* branch < [predicted] */
xx(ao_blt_T,		"blt_T",	mif_bj)	/* branch < [predicted] */
xx(ao_bne,		"bne",		mif_bj)	/* branch != */
xx(ao_bne_N,		"bne_N",	mif_bj)	/* branch != [predicted] */
xx(ao_bne_T,		"bne_T",	mif_bj)	/* branch != [predicted] */
xx(ao_bsr,		"bsr",		mif_bj)	/* branch to subroutine */

/** Jump (mif_bj) instructions */
xx(ao_jmp,		"jmp",		mif_bj)	/* jump */
xx(ao_jsr,		"jsr",		mif_bj)	/* jump to subroutine */
xx(ao_jsr_coroutine,	"jsr_coroutine",mif_bj)/* jump to subroutine return */
xx(ao_ret,		"ret",		mif_bj)	/* return from subroutine */

/** Special (mif_*) instructions */
xx(ao_call_pal,		"call_pal",	mif_bj)/* call privileged arch library */
xx(ao_fetch,		"fetch",	mif_rr)	/* prefetch data */
xx(ao_fetch_m,		"fetch_m",	mif_rr)	/* prefetch data, modify intent */
xx(ao_rpcc,		"rpcc",		mif_rr)	/* read process cycle counter */
xx(ao_trapb,		"trapb",	mif_rr)	/* trap barrier */
xx(ao_excb,		"excb",		mif_rr)	/* exception barrier */
xx(ao_mb,		"mb",		mif_rr)	/* memory barrier */
xx(ao_wmb,		"wmb",		mif_rr)	/* write memory barrier */

/** Floating point load (mif_rr) instructions */
xx(ao_ldf,		"ldf",		mif_rr)	/* load F_floating */
xx(ao_ldg,		"ldg",		mif_rr)	/* load G_floating (D_floating) */
xx(ao_lds,		"lds",		mif_rr)	/* load S_floating */
xx(ao_ldt,		"ldt",		mif_rr)	/* load T_floating */

/** Floating point load immediate (mif_rr) instructions */
xx(ao_ldif,		"ldif",		mif_rr)	/* load immediate F_floating */
xx(ao_ldid,		"ldid",		mif_rr)	/* load immediate D_floating */
xx(ao_ldig,		"ldig",		mif_rr)	/* load immediate G_floating */
xx(ao_ldis,		"ldis",		mif_rr)	/* load immediate S_floating */
xx(ao_ldit,		"ldit",		mif_rr)	/* load immediate T_floating */

/** Floating point store (mif_rr) instructions */
xx(ao_stf,		"stf",		mif_rr)	/* store F_floating */
xx(ao_stg,		"stg",		mif_rr)	/* store G_floating (D_floating) */
xx(ao_sts,		"sts",		mif_rr)	/* store S_floating */
xx(ao_stt,		"stt",		mif_rr)	/* store T_floating */

/** Floating point computational (mif_rr) instructions */
xx(ao_addf,		"addf",		mif_rr)	/* FP add F_floating */
xx(ao_addg,		"addg",		mif_rr)	/* FP add G_floating */
xx(ao_adds,		"adds",		mif_rr)	/* FP add S_floating */
xx(ao_addt,		"addt",		mif_rr)	/* FP add T_floating */
xx(ao_fcmoveq,		"fcmoveq",	mif_rr)	/* FP move if equal to zero */
xx(ao_fcmovne,		"fcmovne",	mif_rr)	/* FP move if not equal to zero */
xx(ao_fcmovlt,		"fcmovlt",	mif_rr)	/* FP move if < zero */
xx(ao_fcmovle,		"fcmovle",	mif_rr)	/* FP move if <= zero */
xx(ao_fcmovgt,		"fcmovgt",	mif_rr)	/* FP move if > zero */
xx(ao_fcmovge,		"fcmovge",	mif_rr)	/* FP move if >= zero */
xx(ao_cpys,		"cpys",		mif_rr)	/* FP copy sign */
xx(ao_cpysn,		"cpysn",	mif_rr)	/* FP copy sign negate */
xx(ao_cpyse,		"cpyse",	mif_rr)	/* FP copy sign and exponent */
xx(ao_cvtql,		"cvtql",	mif_rr)	/* FP convert quadword to longword */
xx(ao_cvtlq,		"cvtlq",	mif_rr)	/* FP convert longword to quadword */
xx(ao_cvtgq,		"cvtgq",	mif_rr)	/* FP convert G_floating to quadword */
xx(ao_cvttq,		"cvttq",	mif_rr)	/* FP convert T_floating to quadword */
xx(ao_cvtqf,		"cvtqf",	mif_rr)	/* FP convert quadword to F_floating */
xx(ao_cvtqg,		"cvtqg",	mif_rr)	/* FP convert quadword to G_floating */
xx(ao_cvtqs,		"cvtqs",	mif_rr)	/* FP convert quadword to S_floating */
xx(ao_cvtqt,		"cvtqt",	mif_rr)	/* FP convert quadword to T_floating */
xx(ao_cvtdg,		"cvtdg",	mif_rr)	/* FP convert D_floating to G_floating */
xx(ao_cvtgd,		"cvtgd",	mif_rr)	/* FP convert G_floating to D_floating */
xx(ao_cvtgf,		"cvtgf",	mif_rr)	/* FP convert G_floating to F_floating */
xx(ao_cvtts,		"cvtts",	mif_rr)	/* FP convert T_floating to S_floating */
xx(ao_cvtst,		"cvtst",	mif_rr)	/* FP convert S_floating to T_floating */
xx(ao_divf,		"divf",		mif_rr)	/* FP divide F_floating */
xx(ao_divg,		"divg",		mif_rr)	/* FP divide G_floating */
xx(ao_divs,		"divs",		mif_rr)	/* FP divide S_floating */
xx(ao_divt,		"divt",		mif_rr)	/* FP divide T_floating */
xx(ao_fabs,		"fabs",		mif_rr)	/* FP absolute value */
xx(ao_fclr,		"fclr",		mif_rr)	/* FP clear */
xx(ao_fmov,		"fmov",		mif_rr)	/* FP move */
xx(ao_mulf,		"mulf",		mif_rr)	/* FP multiply F_floating */
xx(ao_mulg,		"mulg",		mif_rr)	/* FP multiply G_floating */
xx(ao_muls,		"muls",		mif_rr)	/* FP multiply S_floating */
xx(ao_mult,		"mult",		mif_rr)	/* FP multiply T_floating */
xx(ao_fneg,		"fneg",		mif_rr)	/* FP negate */
xx(ao_negf,		"negf",		mif_rr)	/* FP negate F_floating */
xx(ao_negg,		"negg",		mif_rr)	/* FP negate G_floating */
xx(ao_negs,		"negs",		mif_rr)	/* FP negate S_floating */
xx(ao_negt,		"negt",		mif_rr)	/* FP negate T_floating */
xx(ao_subf,		"subf",		mif_rr)	/* FP subtract F_floating */
xx(ao_subg,		"subg",		mif_rr)	/* FP subtract G_floating */
xx(ao_subs,		"subs",		mif_rr)	/* FP subtract S_floating */
xx(ao_subt,		"subt",		mif_rr)	/* FP subtract T_floating */

/** Floating point relational (mif_rr) instructions */
xx(ao_cmpgeq,		"cmpgeq",	mif_rr)	/* FP compare G_floating equal */
xx(ao_cmpglt,		"cmpglt",	mif_rr)	/* FP compare G_floating < */
xx(ao_cmpgle,		"cmpgle",	mif_rr)	/* FP compare G_floating <= */
xx(ao_cmpteq,		"cmpteq",	mif_rr)	/* FP compare T_floating equal */
xx(ao_cmptlt,		"cmptlt",	mif_rr)	/* FP compare T_floating < */
xx(ao_cmptle,		"cmptle",	mif_rr)	/* FP compare T_floating <= */
xx(ao_cmptun,		"cmptun",	mif_rr)	/* FP compare T_floating unordered */

/** Floating point control (mif_bj) instructions */
xx(ao_fbeq,		"fbeq",		mif_bj)	/* FP branch equal to zero */
xx(ao_fbne,		"fbne",		mif_bj)	/* FP branch not equal to zero */
xx(ao_fblt,		"fblt",		mif_bj)	/* FP branch < zero */
xx(ao_fble,		"fble",		mif_bj)	/* FP branch <= zero */
xx(ao_fbgt,		"fbgt",		mif_bj)	/* FP branch > zero */
xx(ao_fbge,		"fbge",		mif_bj)	/* FP branch >= zero */

/** Special floating point (mif_rr) instructions */
xx(ao_mf_fpcr,		"mf_fpcr",	mif_rr)	/* move from FP control register */
xx(ao_mt_fpcr,		"mf_fpcr",	mif_rr)	/* move to FP control register */
