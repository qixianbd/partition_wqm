<!-- this file was generated automatically by noweave --- better not edit it-->
<html><head><title>The Data Flow Analysis Library of Machine SUIF</title></head><body>


<p>
<!-- Give the l2h (LaTeX to HTML) filter some hints-->




<!-- Adjust dimensions before setting \pagestyle: it looks at-->
<!-- some of them-->









<p>
<!-- Replace some noweb.sty definitions to improve page breaks-->

<!-- Was =\@highpenalty (>9999 disallows-->
<!-- ... _any_ break in code)-->
<!-- Use \nwcodepenalty ...--><!-- ... instead of \@highpenalty-->
    <!-- Use \goodbreak ...-->
               <!-- ... instead of \filbreak-->
<p>
<!-- Parenthesize enumerated items-->


<p>
<h1><a name=toc1>The Data Flow Analysis Library of Machine SUIF</a></h1>
<!-- (Leave \title{} at left margin ...-->
<!--  ... to aid HTML extraction.)-->
<address><a name="NWD1">Glenn Holloway </a><br>holloway@deas.harvard.edu <br>Division of Engineering and Applied Sciences <br>Harvard University </address>
<b><em>Compatible with SUIF Release 1.1.2 <br>Revised May 2, 1998</em></b>
<p>

<!--title goes here-->
<!-- Start a new chunk to cause noweb to put source filename in heading-->



<p>
<tableofcontents>
<ul compact>
<li><a href="#toc2">Introduction</a></li>
<li><a href="#toc3">Class bit_vector_problem</a></li>
<li><a href="#toc4">Class bit_vector_problem_plus</a></li>
<li><a href="#toc5">Live Variable Analysis</a></li>
  <ul compact>
  <li><a href="#toc6">Using class live_var_problem</a></li>
    <ul compact>
      <ul compact>
      <li><a href="#toc7">Constructing a live_var_problem.</a></li>
      <li><a href="#toc8">Accessing liveness results.</a></li>
      <li><a href="#toc9">Instruction analysis for registers, real and potential.</a></li>
      <li><a href="#toc10">Accessing liveness results.</a></li>
      </ul>
    </ul>
  <li><a href="#toc11">Extending class live_var_problem</a></li>
  <li><a href="#toc12">Header file for module live_var</a></li>
  </ul>
<li><a href="#toc13">Unset Variable Analysis</a></li>
  <ul compact>
  <li><a href="#toc14">Using class unset_var_problem</a></li>
  <li><a href="#toc15">Extending class unset_var_problem</a></li>
  <li><a href="#toc16">Header file for module unset_var</a></li>
  </ul>
<li><a href="#toc17">Mapping Registers and Symbols to Bit-vector Indices</a></li>
  <ul compact>
    <ul compact>
      <ul compact>
      <li><a href="#toc18">Constructing an operand_bit_manager.</a></li>
      <li><a href="#toc19">Using an operand_bit_manager.</a></li>
      </ul>
    </ul>
  <li><a href="#toc20">Changing the index assignments for hard registers</a></li>
  <li><a href="#toc21">Header file for module operand_bit_manager</a></li>
  </ul>
<li><a href="#toc22">Boolean Bitset Functions</a></li>
  <ul compact>
  <li><a href="#toc23">Using class bitset_function</a></li>
  <li><a href="#toc24">Header file for module bitset_function</a></li>
    <ul compact>
    <li><a href="#toc25">Protected methods: subject to change without notice</a></li>
    <li><a href="#toc26">Private methods: subject to change without notice</a></li>
    <li><a href="#toc27">Inlined code: subject to change without notice</a></li>
    </ul>
  </ul>
<li><a href="#toc28">Connecting to the DFA Library</a></li>
<li><a href="#toc29">Likely Extensions of the DFA Library</a></li>
<li><a href="#toc30">Acknowledgments</a></li>
<li><a href="#toc31">References</a></li>
<li><a href="#toc32">Indecent Exposure</a></li>
  <ul compact>
  <li><a href="#toc33">Class live_var_problem</a></li>
  <li><a href="#toc34">Class unset_var_problem</a></li>
  <li><a href="#toc35">Class operand_bit_manager</a></li>
  <li><a href="#toc36">Class hard_reg_map</a></li>
  </ul>
</ul>
</tableofcontents>
<p><hr>
<h2><a name=toc2>Introduction</a></h2>
<p>
Data flow analysis (DFA) is a textbook example of code reuse
<b>[cite&nbsp;<a href="#NWcite-bibdragon">bibdragon</a>, <a href="#NWcite- bibcrafting"> bibcrafting</a>]</b>.  Available expressions, or live
variables, or reaching definitions, or other useful sets of properties
can be computed for all points in a program using a generic
algorithmic framework.  Typically, the property sets are represented
as bit vectors, and the generic algorithm propagates them iteratively
over a flow graph, transforming them monotonically to reflect the
effects of basic blocks and the confluence of edges, until they
converge at all points.  Different problems have different initial
conditions for the bit vectors (empty or full), different confluence
transformations (union or intersection), different directions of
traversal (with control flow or against it), and different rules for
expressing the effects of a basic block.  But the fact that their
solvers fit a common pattern is useful, because once the framework is
in place, it enables new analyzers to be added quickly and correctly.
<p>
The DFA library of machine SUIF <b>[cite&nbsp;<a href="#NWcite-bibmachsuif">bibmachsuif</a>]</b> (<em>machsuif</em>, for
short) is a framework for iterative, bit-vector-based data flow analyzers.
It builds on machine SUIF's control flow graph (CFG) library <b>[cite&nbsp;<a href="#NWcite-bibcfg">bibcfg</a>]</b>,
<a name="NWD2">but without the need to alter or extend the CFG classes.  Each specific</a>
data flow solver is derived from an abstract <code>bit_vector_problem</code> class,
which incorporates the generic machinery.
Section&nbsp;<a href="#secBitVectorProblem">[-&gt;]</a> describes this class.  For now, the DFA
library contains just one solver, which computes live variables.  The
interfaces of this liveness analyzer and its related utilities are
described in Section&nbsp;<a href="#secLiveVarProblem">[-&gt;]</a>.  Section&nbsp;<a href="#secConnecting">[-&gt;]</a>
gives directions for incorporating the library in SUIF compiler passes, and
Section&nbsp;<a href="#secExtensions">[-&gt;]</a> discusses likely directions for its extension.
<p><h2><a name=toc3><a name="NWD3">Class </a><code>bit_vector_problem</code></a></h2>
<a name="secBitVectorProblem"><b>[*]</b></a>
<p>
The <code>bit_vector_problem</code> class is a parent class for
bit-vector-based DFA problems.  It was modeled after a similar class
originally implemented by Steve Tjiang of Synopsys and Prof.
Todd Mowry's students at the University of Toronto.  Here is its
declaration:
<p>
<pre><a name="NWbitJ-claS-1" href="#NWD3"><dfn>&lt;class <code>bit_vector_problem</code>&gt;=</dfn></a> <b>(<a href="#NWD4">U-&gt;</a>)</b>
const int INFINITY = 0x7fffffff;
enum DFA_direction_type { forward, backward };

class bit_vector_problem {
  private:
    DFA_direction_type dfa_dir;

  protected:
    cfg *the_cfg;
    DFA_direction_type direction()    { return dfa_dir; }

    virtual void build_sets() = 0;
    virtual boolean solver_ops(cfg_node *n) = 0;

  public:
    bit_vector_problem(DFA_direction_type dir, cfg *graph);
    boolean solve(int iteration_limit = INFINITY);
};
</pre><p>
This class is abstract; a particular data flow analyzer is created by
deriving a subclass of it.  The abstract class is explicitly parameterized
by the two arguments of its constructor: the direction (<code>forward</code> or
<code>backward</code>) of bit-vector propagation and the CFG of the program to be
analyzed.  The iterative propagation algorithm is defined by method
<code>solve(iteration_limit)</code>, which returns true unless it reaches
<code>iteration_limit</code> traversals of the CFG before the analysis converges.
<p>
The <code>bit_vector_problem</code> class above is also implicitly parameterized by
its two pure virtual methods:
<ul>
<li><code>build_sets()</code> must initialize the bit vectors for the graph, and
it should represent the effect of each node so that the
solving phase can combine bit vectors, without having to
inspect code.
<li><code>solver_ops(cfg_node *n)</code> finds and combines the bit vectors of
nodes impinging on <code>n</code> and then propagates the result through <code>n</code>
using its precomputed effect description.  These two aspects of
<code>solver_ops</code>'s role are sometimes called <em>confluence</em> and <em>transfer</em>, respectively.  It also detects whether propagation has
produced any change in <code>n</code>'s attached properties.  If so, it
returns true; otherwise, false.
</ul>
<a name="NWD4">Note that nothing in class </a><code>bit_vector_problem</code> dictates the way that
properties are associated with CFG nodes.  Property sets even don't
need to be vectors of bits.  However, Section&nbsp;<a href="#secLiveVarProblem">[-&gt;]</a>
defines a simple scheme for connecting bit vectors with CFG nodes, and this
is likely to be useful for most analyzers.
<p>
Class <code>bit_vector_problem</code> resides in module <code>bit_vector_dfa</code>, which
has the following header file.
<p>
<pre><a name="NWbitJ-bitG-1" href="#NWD4"><dfn>&lt;bit_vector_dfa.h&gt;=</dfn></a>
/* Bit-vector-based dataflow analysis problems */

<a name="NWbitJ-bitG-1-u1" href="#NWDX"><i>&lt;SUIF copyright&gt;</i></a>

#ifndef BIT_VECTOR_DFA_H
#define BIT_VECTOR_DFA_H

<a name="NWbitJ-bitG-1-u2" href="#NWD3"><i>&lt;class <code>bit_vector_problem</code>&gt;</i></a>

#endif /* BIT_VECTOR_DFA_H */
</pre><p>
<!-- -*- mode: Noweb; noweb-code-mode: c++-mode -*--->
<h2><a name=toc4>Class <code>bit_vector_problem_plus</code></a></h2>
<a name="secBitVectorProblemPlus"><b>[*]</b></a>
<p>
The <code>bit_vector_problem_plus</code> class is an attempt to replace
<code>bit_vector_problem</code> for bit-vector-based DFA problems.
<p>
<ul>
<li><a name="NWD5">It adds functionality for initializing bit sets.</a>
<li>It adds standard functionality for handling splits or joins in the
CFG.
<li>It only asks the user to supply Gen and Kill iterators over
(presumably) small sets.  And walks each block once. 
</ul>
<p>
<pre><a name="NWbitO-claX-1" href="#NWD5"><dfn>&lt;class <code>bit_vector_problem_plus</code>&gt;=</dfn></a> <b>(<a href="#NWDD">U-&gt;</a>)</b>
  <a name="NWbitO-claX-1-u1" href="#NWD6"><i>&lt;<code>bit_vector_problem_plus</code> enum&gt;</i></a>

class bit_vector_problem_plus {
private:
  <a name="NWbitO-claX-1-u2" href="#NWDC"><i>&lt;<code>bit_vector_problem_plus</code> private&gt;</i></a>

protected:
  <a name="NWbitO-claX-1-u3" href="#NWDB"><i>&lt;<code>bit_vector_problem_plus</code> protected&gt;</i></a>

public:
  bit_vector_problem_plus(
                          DFA_direction_type dir, 
                          DFA_transfer at_each_instr,
                          DFA_propagation propagation,
                          DFA_keep_info needed_later,
                          int bitset_size,
                          cfg* the_cfg,

                          bitset_function* entry_xfer_fn = NULL,
                          bitset_function* exit_xfer_fn = NULL
                          );
  virtual ~bit_vector_problem_plus();

  bit_set* in_set(cfg_node* basic_block);
  boolean in_set_contains(cfg_node* basic_block, int bit_num);
  bit_set* out_set(cfg_node* basic_block);
  boolean out_set_contains(cfg_node* basic_block, int bit_num);

  boolean solve(int iteration_limit = INFINITY);
  virtual void update_bit_set_size(int);
  void update_bit_set_for_instr(bit_set*,instruction*);
  void print(cfg_node* bb, FILE *fp = stdout); // debugging only
};
</pre><p>
This is an attempt to parameterize the <code>bit_vector_problem</code> class
so that a particular bit vector analysis can be defined using just
some parameters to the definition of a <code>bit_vector_problem</code> and the
actual per instruction generation of appropriate gen and kill sets for
the analysis.  It allows the user to override its standard behavior to
provide special functions for special cases, but if you find yourself
<a name="NWD6">providing too many special functions, then you probably want to write</a>
your own subclass of <code>bit_vector_problem</code>.
<p>
The parameters are as follows:
<ul>
<li><code>dir</code>:  
the direction of the bit vector problem: either <code>forward</code> following
edges in the control flow direction from the <code>ENTRY</code> node or
<code>backward</code> following edges in reverse from the <code>EXIT</code> node.
<p><pre><a name="NWbitO-**bW-1" href="#NWD6"><dfn>&lt;<code>bit_vector_problem_plus</code> enum&gt;=</dfn></a> <b>(<a href="#NWD5">&lt;-U</a>)</b> <b>[D<a href="#NWD7">-&gt;</a>]</b>
/* enum DFA_direction_type { forward, backward }; 
   // defined in bit_vector_dfa.h */
</pre><p>

<li><code>at_each_instr</code>: the transfer operation to be performed at
each instruction <i><tt>S</tt></i> in the basic block is either
<code>standard_t</code> which will cause the calculation of
<blockquote><i>out[<tt>S</tt>] =in[<tt>S</tt>] - kill[<tt>S</tt>] gen[<tt>S</tt>]
</i></blockquote>where <i>in</i> and <i>out</i> depend to the direction of the problem.
<p>
If you set this to <code>special_t</code> then you are responsible for
overriding virtual method <code>special_transfer</code> which takes a pointer
to a <code>bitset_function*</code> and updates the <code>bitset_function*</code> as needed for the
instruction.
!!! oops pass instruction* !!!
<p>
<a name="NWD7">If </a><code>standard_t</code> is used, then you must write methods
<code>gen_iterator_init</code>, <code>gen_iterator</code>, <code>kill_iterator_init</code>, and
<code>kill_iterator</code>.  The <code>_init</code> methods indicate the beginning of
iteration, they should set up any information necessary for the
iterator.  
The <code>_iterator</code> functions return either positive bit
numbers for use in the <code>gen</code> or <code>kill</code> sets, or a negative number
to indicate the end of iteration.  See the <code>protected</code> methods for
more information.
<p><pre><a name="NWbitO-**bW-2" href="#NWD6"><dfn>&lt;<code>bit_vector_problem_plus</code> enum&gt;+=</dfn></a> <b>(<a href="#NWD5">&lt;-U</a>)</b> <b>[<a href="#NWD6">&lt;-</a>D<a href="#NWD8">-&gt;</a>]</b>
enum DFA_transfer { standard_t, special_t };
</pre><p>

<li><code>propagation</code>: 
If <code>propagation</code> is <code>isect_p</code> then for a block <i><tt>B</tt></i>.
<blockquote><i><a name="NWD8">in[</a><tt>B</tt>] = _<tt>P</tt> <b>in</b>pred(<tt>B</tt>)out[<tt>P</tt>]
</i></blockquote>If <code>propagation</code> is <code>union_p</code> then for a block <i><tt>B</tt></i>.
<blockquote><i>in[<tt>B</tt>] = _<tt>P</tt> <b>in</b>pred(<tt>B</tt>)out[<tt>P</tt>]
</i></blockquote>where <i>in</i>, <i>out</i>, and <i>pred</i> depend to the direction of the problem.
<p>
If <code>propagation</code> is <code>special_p</code> then you must supply a function 
<code>special_propagation</code> which takes a <code>cfg_node_list_iter*</code>
and produces the <i>in[<tt>B</tt>]</i> <code>bit_set</code>.
!!! Oops, hook this up to our out sets!!!
<p><pre><a name="NWbitO-**bW-3" href="#NWD6"><dfn>&lt;<code>bit_vector_problem_plus</code> enum&gt;+=</dfn></a> <b>(<a href="#NWD5">&lt;-U</a>)</b> <b>[<a href="#NWD7">&lt;-</a>D<a href="#NWD9">-&gt;</a>]</b>
enum DFA_propagation { isect_p, union_p, special_p };
</pre><p>

<li>Special treatment of <code>entry</code> and <code>exit</code> nodes:
By default <code>bit_map_problem_plus</code> sets the transfer functions for
the <code>entry</code> and <code>exit</code> nodes of the cfg to the identity function.
<p>
It also sets the following values:
<table><!-- alignment is llll--><!-- 4 columns--><tr><td align=left valign=top>direction </td><td align=left valign=top>propagation </td><td align=left valign=top>sets </td><td align=left valign=top>value </td></tr>
<tr><td align=left valign=top><code>forward</code> </td><td align=left valign=top><code>isect_p</code> </td><td align=left valign=top><i>in[<tt>E</tt>NTRY]</i> </td><td align=left valign=top><code>universal</code> </td></tr>
<tr><td align=left valign=top><code>forward</code> </td><td align=left valign=top><code>union_p</code> </td><td align=left valign=top><i>in[<tt>E</tt>NTRY]</i> </td><td align=left valign=top><code>clear</code> </td></tr>
<tr><td align=left valign=top><code>backward</code> </td><td align=left valign=top><code>isect_p</code> </td><td align=left valign=top><i>in[<tt>E</tt>XIT]</i> </td><td align=left valign=top><code>universal</code> </td></tr>
<tr><td align=left valign=top><code>backward</code> </td><td align=left valign=top><code>union_p</code> </td><td align=left valign=top><i>in[<tt>E</tt>XIT]</i> </td><td align=left valign=top><code>clear</code> </td></tr>
</table>
<p>
You can use <code>entry_xfer_fn</code> and <code>exit_xfer_fn</code> to set transfer
functions more appropriate to yout particular problem.
<p>
<li><code>needed_later</code>:
<a name="NWD9">Remember that the term </a><code>in</code> in this code refers to the bit set of
dataflow values at the end of the block <em>entered</em> by the dataflow
analysis: which will be the top of the block for a <code>forward</code>
analysis and will be the bottom of the block for a <code>backward</code>
analysis.
<p>
Your transformation will generally require the <code>in</code> data, wo you
will want to set <code>needed_later</code> to <code>in_k</code>.  But <code>out</code> data may
be saved with <code>out_k</code> and both may be saved with <code>both_k</code>.
<p><pre><a name="NWbitO-**bW-4" href="#NWD6"><dfn>&lt;<code>bit_vector_problem_plus</code> enum&gt;+=</dfn></a> <b>(<a href="#NWD5">&lt;-U</a>)</b> <b>[<a href="#NWD8">&lt;-</a>D<a href="#NWDA">-&gt;</a>]</b>
enum DFA_keep_info { in_k, out_k, both_k };
</pre><p>
</ul>

<a name="NWDA">Other than initilization and deletion, the other public methods are </a>
<ul>
<li><code>solve</code> -- why not immediately: don't create bitsets before
needed by user.
<p><pre><a name="NWbitO-**bW-5" href="#NWD6"><dfn>&lt;<code>bit_vector_problem_plus</code> enum&gt;+=</dfn></a> <b>(<a href="#NWD5">&lt;-U</a>)</b> <b>[<a href="#NWD9">&lt;-</a>D]</b>
/* const int INFINITY = 0x7fffffff; // defined in bit_vector_dfa.h */
</pre><p>

<li><code>in_set</code> -- direction of analysis
<p>
<li><code>in_set_contains</code>
<p>
<li><code>out_set</code>
<p>
<li><code>out_set_contains</code>
<p>
<li><code>update_bit_set_for_instr</code> -- doesn't propagate across blocks,
use <code>solve</code> again if needed.
After creating a <code>bit_vector_problem_plus</code>
</ul>
<p>
Note that nothing in class <code>bit_vector_problem_plus</code> dictates the
way that properties are associated with CFG nodes.  However our
implementation uses the following storage:
<ul>
<li><a name="NWDB">a </a><code>bitset_function</code> for each basic block in the CFG, during <code>solve</code>.
<li>a <code>bit_set</code> <code>in</code> for each basic block, from <code>solve</code>
until the <code>bit_vector_problem_plus</code> object is deleted.  (Assuming
<code>needed_later</code> <i>=</i> <code>in_k</code>).
<li>a bit set <code>out</code> for each edge in the CFG, during <code>solve</code>.
(assuming <code>needed_later</code> <i></i> <code>out_k</code> or <code>both_k</code>).
</ul>
<p>
The protected members of <code>bit_vector_problem_plus</code> are declared:
<p><pre><a name="NWbitO-**bb-1" href="#NWDB"><dfn>&lt;<code>bit_vector_problem_plus</code> protected&gt;=</dfn></a> <b>(<a href="#NWD5">&lt;-U</a>)</b>
  int bitset_size;
  virtual void gen_iterator_init(instruction*) = 0;
  virtual int gen_iterator() = 0;
  virtual void kill_iterator_init(instruction*) = 0;
  virtual int kill_iterator() = 0;
  cfg* the_cfg;
  bitset_function* entry_xfer_fn;
  bitset_function* exit_xfer_fn;
  virtual bit_set* special_propagation(cfg_node_list_iter*);
  virtual void special_transfer(bitset_function*);
  
  DFA_direction_type direction;
  DFA_propagation propagation;
  DFA_transfer transfer;
  DFA_keep_info needed_later;

  void Delete_DFAP_bit_set_array(DFAP_bit_set_array*);
  void Delete_DFAP_bitset_function_array(DFAP_bitset_function_array*);
</pre><p>
<ul>
<li>Helper functions
<blockquote>
<code>void Delete_DFAP_bit_set_array(DFAP_bit_set_array*)</code> and<br><code>void Delete_DFAP_bitset_function_array(DFAP_bitset_function_array*)</code>
</blockquote>
are used by the destructor, but they are made <code>protected</code> so
that they may be used by any derived class that needs to
manipulate similar sets.
<p>
<li>Gen and kill sets are considered to be sparse, so they are calculuated
by iterators supplied by the derived class.
<code><a name="NWDC">void gen_iterator_init(instruction*)</a></code>,
<code>int gen_iterator()</code>,
<code>void kill_iterator_init(instruction*)</code>,
<code>int kill_iterator()</code>
<p>
<li>Other protected members just store data passed to the initialization routine.
</ul>
<p>
The private members of <code>bit_vector_problem_plus</code> are declared:
<p><pre><a name="NWbitO-**bZ-1" href="#NWDC"><dfn>&lt;<code>bit_vector_problem_plus</code> private&gt;=</dfn></a> <b>(<a href="#NWD5">&lt;-U</a>)</b>
DFAP_bitset_function_array* bb_xfer;    // transfer function: per block
DFAP_bit_set_array* bb_in;      // in bitset: per block
DFAP_bit_set_array* bb_out;     // out bitset: per block

void meet(cfg_node*);           // code pulled out of solve for readability
void build_local_info(int);     // code pulled out of solve for readability
</pre><p>

<pre><a name="NWbitO-**bU-1" href="#NWbitO-**bU-1"><dfn>&lt;<code>bit_set_array</code> declarations&gt;=</dfn></a> <b>(<a href="#NWDD">U-&gt;</a> <a href="#NWDI">U-&gt;</a>)</b> <b>[D<a href="#NWDG">-&gt;</a>]</b>
DECLARE_X_ARRAY(DFAP_bit_set_array, bit_set, 100);
DECLARE_X_ARRAY(DFAP_bitset_function_array, bitset_function, 100);
</pre><p>
<a name="NWDD">Class </a><code>bit_vector_problem_plus</code> resides in module
<code>bit_vector_dfa_plus</code>, which has the following header file.
<p>
<pre><a name="NWbitO-bitL-1" href="#NWDD"><dfn>&lt;bit_vector_dfa_plus.h&gt;=</dfn></a>
/* Highly parameterized bit-vector-based dataflow analysis problems */

<a name="NWbitO-bitL-1-u1" href="#NWDX"><i>&lt;SUIF copyright&gt;</i></a>

#ifndef BIT_VECTOR_DFA_PLUS_H
#define BIT_VECTOR_DFA_PLUS_H
/* Using an enumeration and constant defined in bit_vector_dfa.h */
#include &quot;bit_vector_dfa.h&quot;

<a name="NWbitO-bitL-1-u2" href="#NWbitO-**bU-1"><i>&lt;<code>bit_set_array</code> declarations&gt;</i></a>
<a name="NWbitO-bitL-1-u3" href="#NWD5"><i>&lt;class <code>bit_vector_problem_plus</code>&gt;</i></a>

#endif /* BIT_VECTOR_DFA_PLUS_H */
</pre><p>
<h2><a name=toc5>Live Variable Analysis</a></h2>
<a name="secLiveVarProblem"><b>[*]</b></a>
<p>
Aho, Sethi, and Ullman <b>[cite&nbsp;<a href="#NWcite-bibdragon">bibdragon</a>]</b> present live variable analysis as a
typical backward data flow problem.  Our implementation closely follows
their Algorithm 10.4.  The variables on which it operates are operands of
machine SUIF instructions.  A library client invokes the analyzer by
constructing an instance of class <code>live_var_problem</code>, and it accesses the
<a name="NWDE">results via methods of that class.</a>
<p>
<h3><a name=toc6>Using class <code>live_var_problem</code></a></h3>
<p>
Like all instances of <code>bit_vector_problem</code>, a <code>live_var_problem</code> embeds
a CFG at the time it is constructed.  The methods providing liveness results
for each node of the CFG each take the node as an argument.  Here is an
outline of the class:
<p>
<pre><a name="NWlivD-claQ-1" href="#NWDE"><dfn>&lt;class <code>live_var_problem</code>&gt;=</dfn></a> <b>(<a href="#NWDI">U-&gt;</a>)</b>
class live_var_problem : protected bit_vector_problem {
    typedef void (*instruction_def_use_f)
                 (instruction *, operand_bit_manager *, bit_set *, bit_set *);

  public:
    live_var_problem(cfg *, operand_bit_manager *,
                     instruction_def_use_f = Instruction_def_use);
    virtual ~live_var_problem();

    boolean live_in(cfg_node *n, int var_num);
    boolean live_out(cfg_node *n, int var_num);
    bit_set *live_in_set(cfg_node *n);
    bit_set *live_out_set(cfg_node *n);

  protected:
    <a name="NWlivD-claQ-1-u1" href="#NWDH"><i>&lt;<code>live_var_problem</code> protected&gt;</i></a>

  protected:
    <a name="NWlivD-claQ-1-u2" href="#NWDY"><i>&lt;<code>live_var_problem</code> private&gt;</i></a>
};
</pre><p>

<h5><a name=toc7>Constructing a <code>live_var_problem</code>.</a></h5>
<p>
As its declaration above shows, the <code>live_var_problem</code> constructor takes
three arguments:
<ol>
<li>The control flow graph of the program.
<li><a name="enumLvpCtorObm"><b>[*]</b></a>
An <em>operand bit manager</em>, which tells the analyzer how many
variables to expect and provides the mapping from operands
representing variable occurrences to indices in bit vectors.
<li><a name="enumLvpCtorIdu"><b>[*]</b></a>
A function that inspects an instruction and produces two sets:
variables that it defines and variables that it references.
</ol>
The constructor performs the liveness analysis before it returns the
constructed instance.  That is, it invokes <code>bit_vector_problem::solve()</code>.
<p>
Argument (<a href="#enumLvpCtorObm">[&lt;-]</a>), the bit manager, is created as described
in Section&nbsp;<a href="#secOperandBitManager">[-&gt;]</a>.  It tells the liveness analyzer how
big to make the bit vectors that it associates with CFG nodes, and which
bits to turn on to indicate liveness of a set of variables.  It also allows
operands to be screened, so that uninteresting variables are omitted from
the analysis.
<p>
Argument (<a href="#enumLvpCtorIdu">[&lt;-]</a>) provides a way to obtain the operand
definition and use semantics of instructions in the program.  It is a
function taking two inputs and two result parameters.  The inputs are an
instruction and a bit manager for identifying operands.  The results are
bit vectors that must be modified by the function to reflect variables
defined and variables used, respectively, by its instruction argument.
This functional parameter of the <code>live_var_problem</code> constructor can be
omitted.  In that case, the helper function <code>Instruction_def_use()</code> is
used.  Its behavior is described just below.
<p>
<h5><a name=toc8>Accessing liveness results.</a></h5>
<p>
There are two pairs of methods for accessing the results of liveness
analysis at a given CFG node.
<p>
<ul>
<li>Method <code>live_in(cfg_node *n, int v)</code> returns true exactly when the
variable with index <code>v</code> is live on entry to node <code>n</code>.  Method
<code>live_out(cfg_node *n, int v)</code> is similar for exit from <code>v</code>.
<li>Method <code>live_in_set(cfg_node *n)</code> returns (a pointer to) a bit
vector representing variables live on entry to <code>n</code>;
<code>live_out_set(cfg_node *n)</code> similarly returns the set live on exit.
<a name="NWDF">The caller should not modify the result sets of these methods.</a>
</ul>
<p>
<h5><a name=toc9>Instruction analysis for registers, real and potential.</a></h5>
<p>
For cases in which the variables of interest are registers, virtual
registers <b>[cite&nbsp;<a href="#NWcite-bibmachsuif">bibmachsuif</a>]</b>, and symbols that might be assigned to
registers, the library provides this utility:
<p>
<pre><a name="NWlivD-funW-1" href="#NWDF"><dfn>&lt;function <code>Instruction_def_use</code>&gt;=</dfn></a> <b>(<a href="#NWDI">U-&gt;</a>)</b>
void Instruction_def_use(instruction *, operand_bit_manager *,
                         bit_set *def, bit_set *use);
</pre><p>
This function first clears result vectors <code>def</code> and <code>use</code>,
then it scans the operands of the instruction.  Using its bit
manager parameter to screen operands and to set bits, it
reflects destination operand occurrences in <code>def</code> and source
occurrences in <code>use</code>.  Sources within effective address (EA)
operands are treated similarly, but a symbol occurring as a
memory reference in an EA calculation is not treated as a
variable occurrence.
<p>
For the most part, <code>Instruction_def_use()</code> ignores opcodes.
It does, however, treat call and return instructions specially:
<ul>
<li>At a call, it uses the <code>k_regs_used</code> annotation to
determine what registers are being used to pass arguments;
it adds these to <code>use</code>. It also treats all argument,
result, temporary, and assembler-temporary registers, in
all banks, as ``defined'' by the callee, and so adds them
to <code>def</code>.
<li>At a return, it uses the <code>k_instr_ret</code> annotation to
decide whether a result is being returned in registers,
and if so to mark the appropriate result register(s) in
<code>use</code>.
</ul>
Function <code>Instruction_def_use()</code> is exported for use beyond the
liveness application.  The register allocator <code>raga</code>, for example,
uses it as well.
<p>
<h5><a name=toc10>Accessing liveness results.</a></h5>
<p>
Method <code>live_in(cfg_node *n, int v)</code> of <code>live_var_problem</code>
returns true exactly when the variable with index <code>v</code> is live
on entry to node <code>n</code>.  Method <code>live_out(cfg_node *n, int v)</code>
is similar for exit from <code>v</code>.
Liveness information can also be obtained in set form:
<code>live_in_set(cfg_node *n)</code> returns (a pointer to) the bit
vector representing variables live on entry to <code>n</code>;
<code>live_out_set(cfg_node *n)</code> similarly returns the set live on
exit.  These results may or may not point to copies; the caller
should not modify the result sets.
<p>
<h3><a name=toc11>Extending class <code>live_var_problem</code></a></h3>
<p>
It has proven handy to make most of the implementation of
<code>live_var_problem</code> accessible to derived classes, so we now
<a name="NWDG">describe the protected part of its interface.</a>
<p>
The implementation defines and extensible-array type
<code>bit_set_array</code> that it uses to map CFG nodes to bit vectors.
For storage reclamation, it also provides a helper function
<code>Delete_bit_set_array(bit_set_array *a)</code> that invokes <code>delete</code> on
<code>a</code> after first <code>delete</code>'ing each of its elements.  The array
type and the delete function are declared by:
<p>
<pre><a name="NWlivD-**bU-2" href="#NWbitO-**bU-1"><dfn>&lt;<code>bit_set_array</code> declarations&gt;+=</dfn></a> <b>(<a href="#NWDD">&lt;-U</a> <a href="#NWDI">U-&gt;</a>)</b> <b>[<a href="#NWbitO-**bU-1">&lt;-</a>D]</b>
DECLARE_X_ARRAY(bit_set_array, bit_set, 1024);

void Delete_bit_set_array(bit_set_array *);
</pre><p>
<a name="NWDH">The protected members of </a><code>live_var_problem</code> are declared:
<p><pre><a name="NWlivD-**lU-1" href="#NWDH"><dfn>&lt;<code>live_var_problem</code> protected&gt;=</dfn></a> <b>(<a href="#NWDE">&lt;-U</a>)</b>
operand_bit_manager *bit_man;
bit_set_array *defs;
bit_set_array *uses;
bit_set_array *live_ins;
bit_set_array *live_outs;

void build_sets();
boolean solver_ops(cfg_node *);

virtual void build_local_info(int n);
virtual void note_instr_def_use(int node, instruction *,
                                bit_set *def, bit_set *use);
</pre><p>
Here is a rundown of their meanings.
<ul>
<li><code>bit_man</code>, the bit manager, provides the size of bit vectors for
the current problem.
<li>The <code>defs</code> and <code>uses</code> arrays map a CFG node to the local
information needed when solving for liveness.  <code>(*defs)[n]</code> is
the set of variables defined before being used in node number
<code>n</code>.  <code>(*uses)[n]</code> is the set used before being defined.
<li>The <code>live_ins</code> and <code>live_outs</code> arrays map a CFG node's number
to the set of variables live on entry or exit to that node,
respectively.
<li><code>build_sets()</code> and <code>solver_ops(cfg_node *)</code> are the virtual methods
that must be defined to satisfy the base class <code>bit_vector_problem</code>.
<li><code>build_local_info(n)</code> computes <code>(*defs)[n]</code> and <code>(*uses)[n]</code>.
It is declared <code>virtual</code> as a ``hook'' for extenders to hang new
functionality on.
<li><code>note_instr_def_use(int n, instruction *instr, bit_set *def, bit_set *use)</code><br>is called in <code>build_local_info(n)</code> to assimilate the effect of
instruction <code>instr</code> on local liveness information.  It also
leaves <code>def</code> and <code>use</code> holding the def/use vectors for
<code>instr</code>.  This helps make it another useful hook point.
</ul>
<p>

<h3><a name=toc12><a name="NWDI">Header file for module </a><code>live_var</code></a></h3>
<p>
Class <code>live_var_problem</code>, type <code>bit_set_array</code>, and the helper
<code>Instruction_def_use()</code> are defined in module <code>live_var</code>, which has
the following header file.
<p>
<pre><a name="NWlivD-livA-1" href="#NWDI"><dfn>&lt;live_var.h&gt;=</dfn></a>
/* Interface for bit-vector-based live-variable analyzer */

<a name="NWlivD-livA-1-u1" href="#NWDX"><i>&lt;SUIF copyright&gt;</i></a>

#ifndef LIVE_VAR_H
#define LIVE_VAR_H

<a name="NWlivD-livA-1-u2" href="#NWbitO-**bU-1"><i>&lt;<code>bit_set_array</code> declarations&gt;</i></a>

<a name="NWlivD-livA-1-u3" href="#NWDF"><i>&lt;function <code>Instruction_def_use</code>&gt;</i></a>

<a name="NWlivD-livA-1-u4" href="#NWDE"><i>&lt;class <code>live_var_problem</code>&gt;</i></a>
#endif /* LIVE_VAR_H */
</pre><p>
<h2><a name=toc13>Unset Variable Analysis</a></h2>
<a name="secUnsetVarProblem"><b>[*]</b></a>
<p>
Unset variable analysis is a simple forward-flow problem that determines,
for any program point, the set of variables that have no definition
reaching that point.  If a variable is used at a point where it is
``unset'' in this sense, its value is unpredictable and the program is
probably incorrect.
<p>
Of course, in a correct program a variable can be live at a point in a
without having a meaningful value there, assuming that it is initialized
before it is actually used at runtime.  In register allocation, it's useful
to recognize the live ranges of a variable by intersecting the results of
unset variable analysis with liveness information.
<p>

<h3><a name=toc14>Using class <code>unset_var_problem</code></a></h3>
<p>
The unset variable problem is similar to the liveness problem in that the
items whose flow is of interest are storable locations.  Therefore the
<a name="NWDJ">operand bit manager (Section&nbsp;</a><a href="#secOperandBitManager">[-&gt;]</a>) plays a similar
role in both solvers.  Their implementations differ because unset-variables
pays attention only to definitions, not to uses.  Moreover, it is a
forward-flow problem instead of backward, it uses intersection instead of
union as its confluence operator, and it starts from universal (full) bit
vectors rather than empty ones.  However, the definition, use and extension
of class <code>unset_var_problem</code> are analogous to those of class
<code>live_var_problem</code> (Section&nbsp;<a href="#secLiveVarProblem">[&lt;-]</a>).
<p>
<pre><a name="NWunsE-claR-1" href="#NWDJ"><dfn>&lt;class <code>unset_var_problem</code>&gt;=</dfn></a> <b>(<a href="#NWDL">U-&gt;</a>)</b>
class unset_var_problem : protected bit_vector_problem {
    typedef void (*instruction_def_use_f)
                 (instruction *, operand_bit_manager *, bit_set *, bit_set *);

  public:
    unset_var_problem(cfg *, operand_bit_manager *,
                      instruction_def_use_f = Instruction_def_use);
    virtual ~unset_var_problem();

    boolean unset_in(cfg_node *n, int var_num);
    boolean unset_out(cfg_node *n, int var_num);
    bit_set *unset_in_set(cfg_node *n);
    bit_set *unset_out_set(cfg_node *n);

  protected:
    <a name="NWunsE-claR-1-u1" href="#NWDK"><i>&lt;<code>unset_var_problem</code> protected&gt;</i></a>

  private:
    <a name="NWunsE-claR-1-u2" href="#NWDZ"><i>&lt;<code>unset_var_problem</code> private&gt;</i></a>
};
</pre><p>

The <code>unset_var_problem</code> constructor declared above takes three arguments:
<ol>
<li>The control flow graph of the program.
<li>An operand bit manager giving the number of variables to allow for
in the analysis and providing the map from operands representing
relevant variables to indices in bit vectors.
<li>A function that analyzes the variables defined and used by one
instruction.  (The information about variable uses isn't needed, but
it allows sharing of a single instruction-analysis helper function.)
</ol>
The constructor performs the unsetness analysis before returning the
<a name="NWDK">constructed instance by invoking </a><code>bit_vector_problem::solve()</code>.
<p>

<h3><a name=toc15>Extending class <code>unset_var_problem</code></a></h3>
<p>
The protected members of <code>unset_var_problem</code> are declared as
for class <code>live_var_problem</code>, except that variable uses are not
of interest.
<p>
<pre><a name="NWunsE-**uV-1" href="#NWDK"><dfn>&lt;<code>unset_var_problem</code> protected&gt;=</dfn></a> <b>(<a href="#NWDJ">&lt;-U</a>)</b>
operand_bit_manager *bit_man;
bit_set_array *defs;
bit_set_array *unset_ins;
bit_set_array *unset_outs;

void build_sets();
boolean solver_ops(cfg_node *);

virtual void build_local_info(int n);
virtual void note_instr_def(int node, instruction *, bit_set *def);
</pre><p>

Here is a review of the meanings of the above-declared members.
<ul>
<li><code>bit_man</code>, the bit manager, provides the size of bit vectors for
the current problem and screens out irrelevant operands.
<li>The <code>defs</code> array maps a CFG node to the local
information needed when solving for liveness.  <code>(*defs)[n]</code> is
the set of variables defined before being used in node number
<code>n</code>.
<li>The <code>unset_ins</code> and <code>unset_outs</code> arrays map a CFG node's number
to the set of variables definitely uninitialized on entry or exit to
that node, respectively.
<li><code>build_sets()</code> and <code>solver_ops(cfg_node *)</code> are the virtual methods
that must be defined to satisfy the base class <code>bit_vector_problem</code>.
<li><code>build_local_info(n)</code> computes <code>(*defs)[n]</code>.
It is declared <code>virtual</code> as a ``hook'' for extenders to hang new
functionality on.
<li><code><a name="NWDL">note_instr_def_use(int n, instruction *instr, bit_set *def)</a></code><br>is called in <code>build_local_info(n)</code> to assimilate the effect of
instruction <code>instr</code> on local unsetness information.  It also
leaves <code>def</code> holding the defined-variable set for
<code>instr</code>.  This makes it another useful hook point.
</ul>
<p>

<h3><a name=toc16>Header file for module <code>unset_var</code></a></h3>
<p>
<pre><a name="NWunsE-unsB-1" href="#NWDL"><dfn>&lt;unset_var.h&gt;=</dfn></a>
/* Interface for bit-vector-based unset variable analyzer */

<a name="NWunsE-unsB-1-u1" href="#NWDX"><i>&lt;SUIF copyright&gt;</i></a>

#ifndef UNSET_VAR_H
#define UNSET_VAR_H

<a name="NWunsE-unsB-1-u2" href="#NWDJ"><i>&lt;class <code>unset_var_problem</code>&gt;</i></a>
#endif /* UNSET_VAR_H */
</pre><p>
<h2><a name=toc17>Mapping Registers and Symbols to Bit-vector Indices</a></h2>
<a name="secOperandBitManager"><b>[*]</b></a>
<p>
Specific solvers of bit-vector problems need to be told how large to make
the vectors and how to map a variable or expression in the program to one or
more bits in a bit vector.  For the common case in which the program
entities of interest are register and symbol operands, an <em>operand bit
manager</em> serves these purposes.  Before analysis, as the program to be
analyzed is first scanned, it assigns bit indices to operands.  During
analysis, as operands are revisited, it provides efficient lookup of their
indices.
<p>
In general, a bit manager may assign more than one bit to an operand.  A
hard-register operand's type may indicate that it spans more than one
natural (i.e., physical) register.  In that case, the bit manager gives it
a range of indices covering the physical registers it represents.  For
architectures with addressable subregisters, many analyzers want to treat
subregister grains <b>[cite&nbsp;<a href="#NWcite-bibmachsuif">bibmachsuif</a>]</b> as potentially independent resources.
In that case, the bit manager associates a range of indices with each
natural register in the bank.  The indices for a particular hard register
operand are again a function of both its register number and its type.
As a special case, a hard register operand with <code>type_void</code> as its type
is treated as though its type had size equal to the natural width of the
register.
<p>
For example, on the MIPS-I architecture, <em>machsuif</em> might refer to
register <code>$f4</code> using the integer <i>52</i>.  An operand having that register
number and <code>type_double</code> as its type is assigned the bit range
<tt>[</tt>52,53<tt>]</tt>, since a <code>double</code> spans two registers in the
floating-point bank.  On the <i>x86</i>, a register operand with
number 8 refers to general-purpose register <code>A</code>.  With <code>type_signed</code>
<a name="NWDM">(or </a><code>type_void</code>) as its type, the bit range given to it is
<tt>[</tt>8,11<tt>]</tt>.  With <code>type_char</code> instead, its bit range is the
singleton <tt>[</tt>8<tt>]</tt>.
<p>
Virtual registers and symbols always have single-bit ranges, but the
same methods are used for dealing with them as for hard registers.
<p>
The class of operand bit managers is declared as follows:
<p>
<pre><a name="NWopeO-claT-1" href="#NWDM"><dfn>&lt;class <code>operand_bit_manager</code>&gt;=</dfn></a> <b>(<a href="#NWDP">U-&gt;</a>)</b>
class hard_reg_map;

class operand_bit_manager {
  public:
    typedef boolean (*filter_f)(operand);

    operand_bit_manager(filter_f = NULL, hard_reg_map * = NULL,
                        int hash_table_size = 1024,
                        boolean reverse_map = FALSE);
    ~operand_bit_manager();

    <a name="NWopeO-claT-1-u1" href="#NWDN"><i>&lt;<code>operand_bit_manager</code> public&gt;</i></a>
    
  private:
    <a name="NWopeO-claT-1-u2" href="#NWDa"><i>&lt;<code>operand_bit_manager</code> private&gt;</i></a>
};
</pre><p>

<h5><a name=toc18>Constructing an <code>operand_bit_manager</code>.</a></h5>
<p>
As can be seen above, the constructor for class <code>operand_bit_manager</code>
takes four arguments.  All are optional.

<ol>
<li>An optional filter predicate, a boolean function taking an operand
as argument.  If the filter is provided, the bit manager ignores any
operand for which the filter returns false.
<li><a name="enumObmCtorHrm"><b>[*]</b></a>
An optional replacement for the map assigning index ranges to hard
registers.  By default, the first index in the range for a hard
register operand is its abstract register number, and each bit stands
for one addressable grain.  Section&nbsp;<a href="#secHardRegMap">[-&gt;]</a> describes how
to override this assignment by supplying a customized hard register
map, and tells why that might be useful.
<li>An optional bucket count for the bit manager's hash table.
Overriding the default value may affect performance, but not the
table's capacity.
<li>An optional flag that, if true, causes the manager to build a reverse
<a name="NWDN">map from operands to their starting indices.</a>
</ol>
<p>

<h5><a name=toc19>Using an <code>operand_bit_manager</code>.</a></h5>
<p>
The public methods of an operand bit manager object are declared as
follows:
<p>
<pre><a name="NWopeO-**oU-1" href="#NWDN"><dfn>&lt;<code>operand_bit_manager</code> public&gt;=</dfn></a> <b>(<a href="#NWDM">&lt;-U</a>)</b>
int num_bits() { return next_index; }

boolean enroll(operand, int *index_ptr = NULL, int *count_ptr = NULL);
void    enroll(instruction *);

boolean lookup(operand, int *index_ptr = NULL, int *count_ptr = NULL);
boolean forget(operand);

boolean insert(operand, bit_set *);
boolean remove(operand, bit_set *);

operand retrieve(int index, int skip);
void print_entries(bit_set *, FILE *);

boolean intersects(operand, bit_set *);
boolean dst_intersects(instruction *, bit_set *);
boolean src_intersects(instruction *, bit_set *);
</pre><p>
Here's how the above methods are used.
<ul>
<li><code>num_bits()</code> returns the total number of bits allocated so far for
all enrolled symbols and registers, including hard registers (which
are enrolled automatically when the manager is constructed).  This is
the method that a data flow analyzer calls to find out how many bits
to allocate in each bit vector.
<li><code>enroll(operand opd, int *index_ptr, int *count_ptr)</code> tries to put
<code>opd</code> under management. It returns true exactly when the operand is
new and is entered successfully (not filtered out).  In addition, if
the method's optional arguments <code>index_ptr</code> and/or <code>count_ptr</code>
are supplied, it uses them to return the bit range for the operand,
if it has one.  The first index is stored through <code>index_ptr</code>; the
length of the range, through <code>count_ptr</code>.  Return of the bit range
via the optional result parameters may occur whether the operand is
new or old.  In particular, if a hard register has a bit range, it
will be returned, although a hard register is never considered
``new'' to the manager.
<li><code>enroll(instruction *)</code> tries to enroll all the operands of its
instruction argument.  It returns nothing.
<li><code>lookup(operand opd, int *index_ptr, int *count_ptr)</code> returns true
if <code>opd</code> is under management, and in that case, optionally returns
its bit range through result parameters.  It is similar to
<code>enroll(opd, index_ptr, count_ptr)</code>, but it doesn't enroll a new
operand, and it returns true exactly when the <code>opd</code> is already
under management.  Thus it can return true for a hard register
operand that passes the filter and has an associated bit range.
<li><code>forget(operand opd)</code> removes <code>opd</code> from management without
affecting the index assignents of other operands.  It does nothing
if <code>opd</code> represents a hard register.  It returns true exactly when
it makes a change, i.e., when it causes <code>opd</code> to be forgotten.
<li><code>insert(operand opd, bit_set *bv)</code> uses the bit manager to turn on
the bits for an <code>opd</code> in bit vector <code>bv</code>.  It returns true unless
<code>opd</code> is not under management.
<li><code>remove(operand opd, bit_set *bv)</code> is like <code>insert(opd, *bv)</code>,
but it turns the bits for <code>opd</code> in <code>bv</code> off instead of on.
<li><code>retrieve(int index, int skip)</code> returns the operand whose index
range begins at <code>index</code>, or else the null operand, if no such
operand has been recorded.  Since it is possible for more than one
operand's range to begin at the same index, parameter <code>skip</code> says
how many to skip before returning one.  Note that <code>retrieve</code> can
only return a non-null operand if the <code>reverse_map</code> option is true
when the bit manager is created.
<li><code>print_entries(bit_set *bv, FILE *file)</code> prints on <code>file</code> a
representation of the operands whose index ranges are covered by
<code>bv</code>.  Requires that the manager was created with the
<code>reverse_map</code> option true.
<li><code>intersects(operand opd, bit_set *bv)</code> returns true exactly when
any of the bits for <code>opd</code> are turned on in bit vector <code>bv</code>.
<li><code>dst_intersects(instruction *instr, bit_set *bv)</code> returns true if
there is any destination operand <code>opd</code> in <code>instr</code> such that
<code>intersects(opd, bv)</code> is true.
<li><code>src_intersects(instruction *instr, bit_set *bv)</code> is like
<code>dst_intersects(instr, bv)</code>, but for the source operands of
<code>instr</code>.
</ul>
<p>

<h3><a name=toc20>Changing the index assignments for hard registers</a></h3>
<a name="secHardRegMap"><b>[*]</b></a>
<p>
In some applications of class <code>operand_bit_manager</code>, it's not necessary
to allocate space in bit vectors for every addressable grain of every hard
register bank.  The register allocator <code>raga</code>, for example, processes one
bank at a time, and it never treats subregister grains independently.
Furthermore, its observed performance is quite sensitive to the sizes of
the bit vectors in use.  That's the reason for the optional
argument&nbsp;(<a href="#enumObmCtorHrm">[&lt;-]</a>) of <code>operand_bit_manager</code>'s constructor.
It lets the client control which subset of the architecture's registers are
considered ``under management'' and exactly which bit ranges are assigned
to each.
<p>
Class <code>hard_reg_map</code> provides this information, albeit in a slightly
indirect way.  An instance of <code>hard_reg_map</code> maps an abstract register
number to a pair (<code>index</code>, <code>size</code>), where <code>index</code> is to be the
start of the register's assigned bit range, and <code>size</code> is the amount of
register turf (in bits) to be represented by each bit in the range.  For
example, suppose the mapping for the <i>x86</i>'s register 20, which is 
general-purpose register <code>B</code>, has the entry <i>(16, 8)</i>.  Then a register
operand with register number 20 and type <code>type_signed</code> is
given the index range <i>[16,19]</i> because the 32-bit type has four 8-bit
pieces.   On the other hand, if register 20 maps instead to <i>(4, 32)</i>, then
the same operand would get the singleton range <i>[4]</i>.
<p>
<a name="NWDO">When building a </a><code>hard_reg_map</code>, it is only necessary to specify each
register to be managed and give its size-per-vector-bit, i.e., the number
of its bits to be covered by a single bit-vector entry.  Starting indexes
are assigned automatically, in the order in which registers are entered in
the map.
<p>
Class <code>hard_reg_map</code> is declared:
<p>
<pre><a name="NWopeO-claM-1" href="#NWDO"><dfn>&lt;class <code>hard_reg_map</code>&gt;=</dfn></a> <b>(<a href="#NWDP">U-&gt;</a>)</b>
class hard_reg_map {
  public:
    hard_reg_map();
    hard_reg_map(int capacity);
    ~hard_reg_map();
    inline int length();
    void enter(int reg, int size, boolean overlay = FALSE);
    int index(int reg);
    int size(int reg);

  private:
    <a name="NWopeO-claM-1-u1" href="#NWDf"><i>&lt;<code>hard_reg_map</code> private&gt;</i></a>
};

<a name="NWopeO-claM-1-u2" href="#NWDg"><i>&lt;<code>hard_reg_map</code> inline&gt;</i></a>
</pre><p>
Here's the rundown of its public methods:
<ul>
<li><code>hard_reg_map()</code> creates the full, ``natural'' map for the
current <code>target_arch</code>.  That is, it places every register under
management, it gives each its own abstract number as starting index,
and a size-per-vector-bit equal to the addressable grain size for its
bank.
<li><code>hard_reg_map(int capacity)</code> creates a map accommodating register
numbers from 0 to <code>capacity-1</code>.  However, it shows <em>no</em>
registers under management;  they must be entered explicitly by
calling method <code>enter()</code>.  Normally, <code>capacity</code> is the total number
of addressable grains for the current <code>target_arch</code>.
<li><code>length()</code> yields the number of bits allocated to registers entered
in the map so far.
<li><code>enter(int reg, int size, boolean overlay)</code> adds register <code>reg</code>
to the map, with <code>size</code> as its size-per-vector-bit.  By default,
<code>overlay</code> is false; in that case, this method assigns one or more
new bits to cover <code>reg</code> and increases <code>length()</code> by the number
assigned.  When <code>overlay</code> is true, no new bit index is assigned;
instead, the last one assigned is reused.
<li><code>index(int reg)</code> returns the starting bit index associated with
<code>reg</code>.
<li><code><a name="NWDP">size(int reg)</a></code> returns the size-per-vector-bit for <code>reg</code>.
</ul>
<p>

<h3><a name=toc21>Header file for module <code>operand_bit_manager</code></a></h3>
<p>
Classes <code>operand_bit_manager</code> and <code>hard_reg_map</code> are defined in module
<code>operand_bit_manager</code>, which has the following header file:
<p>
<pre><a name="NWopeO-opeL-1" href="#NWDP"><dfn>&lt;operand_bit_manager.h&gt;=</dfn></a>
/*  Operand bit manager interface */

<a name="NWopeO-opeL-1-u1" href="#NWDX"><i>&lt;SUIF copyright&gt;</i></a>

#ifndef OPERAND_BIT_MANAGER_H
#define OPERAND_BIT_MANAGER_H
   
<a name="NWopeO-opeL-1-u2" href="#NWDM"><i>&lt;class <code>operand_bit_manager</code>&gt;</i></a>

<a name="NWopeO-opeL-1-u3" href="#NWDO"><i>&lt;class <code>hard_reg_map</code>&gt;</i></a>

#endif /* OPERAND_BIT_MANAGER_H */
</pre><p>
<!-- -*- mode: Noweb; noweb-code-mode: c++-mode -*--->
<h2><a name=toc22>Boolean Bitset Functions</a></h2>
<a name="secBitsetFunctions"><b>[*]</b></a>
<p>
Muchnick, <b>[cite&nbsp;<a href="#NWcite-bibmuchnick">bibmuchnick</a>]</b>, and many other authors present the
theoretical basis for dataflow problems in terms of ``flow functions''
or ``transfer functions''.
<p>
Here we define the three monotone boolean <i></i> boolean functions,
extended pointwise to  sets of booleans.  
We define useful routines for applying these functions to <code>bitset</code>s.
This will allow us to encode operations on <code>bitset</code>s directly from
the theory.
<p>
The reason that we can get away with using the theory in practice is
that there are only three monotone boolean functions (the identity
function, the function that always returns the constant top (true, 1),
and the function that always returns the constant bottom (false, 0).
<a name="NWDQ">So we only need two bits to represent a monotone boolean </a><i></i> boolean
function. 
Thus the pointwise extension of boolean functions to sets of sets of
booleans, can be represented in only twice as much space as the
<code>bitset</code>s that they manipulate.
<p>

<h3><a name=toc23>Using class <code>bitset_function</code></a></h3>
<p>
<pre><a name="NWbitK-claP-1" href="#NWDQ"><dfn>&lt;class <code>bitset_function</code>&gt;=</dfn></a> <b>(<a href="#NWDR">U-&gt;</a>)</b>
class bitset_function {
private:
  <a name="NWbitK-claP-1-u1" href="#NWDT"><i>&lt;<code>bitset_function</code> private&gt;</i></a>

protected:
  <a name="NWbitK-claP-1-u2" href="#NWDS"><i>&lt;<code>bitset_function</code> protected&gt;</i></a>

public:
  bitset_function(int initial_number_of_bits);
  ~bitset_function();
  bitset_function(const bitset_function&amp;);
  bitset_function&amp; operator=(const bitset_function&amp;);

  void topfn()            <a name="NWbitK-claP-1-u3" href="#NWDU"><i>&lt;<code>bitset_function::topfn()</code> inlined&gt;</i></a>
  void topfn(int bitnum)  <a name="NWbitK-claP-1-u4" href="#NWbitK-**bg-1"><i>&lt;<code>bitset_function::topfn(bitnum)</code> inlined&gt;</i></a>
  void botfn()            <a name="NWbitK-claP-1-u5" href="#NWbitK-**ba.2-1"><i>&lt;<code>bitset_function::botfn()</code> inlined&gt;</i></a>
  void botfn(int bitnum)  <a name="NWbitK-claP-1-u6" href="#NWbitK-**bg.2-1"><i>&lt;<code>bitset_function::botfn(bitnum)</code> inlined&gt;</i></a>
  void idfn()             <a name="NWbitK-claP-1-u7" href="#NWbitK-**bZ.2-1"><i>&lt;<code>bitset_function::idfn()</code> inlined&gt;</i></a>
  void idfn(int bitnum)   <a name="NWbitK-claP-1-u8" href="#NWbitK-**bf-1"><i>&lt;<code>bitset_function::idfn(bitnum)</code> inlined&gt;</i></a>

  void apply(bit_set* updated) <a name="NWbitK-claP-1-u9" href="#NWbitK-**bh-1"><i>&lt;<code>bitset_function::apply(updated)</code> inlined&gt;</i></a>
  void compose(const bitset_function* old) <a name="NWbitK-claP-1-u10" href="#NWbitK-**bf.2-1"><i>&lt;<code>bitset_function::compose(old)</code> inlined&gt;</i></a>

  void print(FILE* fp = stdout);
};
</pre><p>
When you create a boolean bitset function, it is initialized to the
identity function.
<p>
<code>topfn(n)</code> modifies the function to set bit <code>n</code> to 1 (top).
<p>
<code>topfn()</code> modifies the function to set all bits to 1 (top).
<p>
<code>botfn(n)</code> modifies the function to set bit <code>n</code> to 0 (bottom).
<p>
<code>botfn()</code> modifies the function to set all bits to 0 (bottom).
<p>
<code>idfn(n)</code> modifies the function to pass the value of bit <code>n</code> unchanged.
<p>
<code>idfn()</code> modifies the function to pass the values of all bits unchanged.
<p>
<code>apply(b)</code> applies the boolean function to a <code>bit_set*</code> <code>b</code>,
overwriting <code>b</code>.
<p>
<code>f.compose(g)</code> sets the function <code>f</code> to <code>f</code><i> o </i><code>g</code>, overwriting <code>f</code>.
<p>
We provide the standard copy constructor and assignment operator
<a name="NWDR">functionality which may be used in combination with </a><code>compose</code> to
perform nondestructuve composition (by performing destructuve
composition on a copy).
<p>
<h3><a name=toc24>Header file for module <code>bitset_function</code></a></h3>
<p>
Class <code>bitset_function</code> is  defined in module <code>bitset_function</code>, which has
the following header file.
<p>
<pre><a name="NWbitK-bitH-1" href="#NWDR"><dfn>&lt;bitset_function.h&gt;=</dfn></a>
/*  Bit Set Definitions */

<a name="NWbitK-bitH-1-u1" href="#NWDX"><i>&lt;SUIF copyright&gt;</i></a>

#ifndef BITSET_FUNCTION_H
#define BITSET_FUNCTION_H

#pragma interface

<a name="NWbitK-bitH-1-u2" href="#NWDQ"><i>&lt;class <code>bitset_function</code>&gt;</i></a>
#endif /* BITSET_FUNCTION_H */
</pre><p>

<a name="NWDS">Close your eyes: the content of the following sections is are not for</a>
public viewing and may change without notice.
<p>
<h4><a name=toc25>Protected methods: subject to change without notice</a></h4>
<p>
<pre><a name="NWbitK-**bT-1" href="#NWDS"><dfn>&lt;<code>bitset_function</code> protected&gt;=</dfn></a> <b>(<a href="#NWDQ">&lt;-U</a>)</b>
int hbn;
bit_set* id;
bit_set* cs;
bitset_function();
</pre><p>
<code>hbn</code> is the number of the first unused bit (or the number of bits
managed by the bitset_function since it always manages bits starting
from bit 0).
<p>
<code>id</code> is a bitset.  If <code>id(n) == 0</code> then the function is a constant
function at <code>n</code>.  If <code>id(n) == 1 &amp;&amp; cs(n) == 0</code> then the function
is the identity function at <code>n</code>.
<p>
<code>cs</code> is a bitset.  If <code>id(n) == 0 &amp;&amp; cs(n) == 0</code> then the function
<a name="NWDT">is the constant bottom function at </a><code>n</code>.  <code>id(n) == 0 &amp;&amp; cs(n) == 1</code>
then the function is the constant top function at <code>n</code>.
<p>
<code>bitset_function()</code> is a constructor for internal use: private and
protected variables are set to default values and must be updated later
before the function is usable.
<p>
<h4><a name=toc26>Private methods: subject to change without notice</a></h4>
<p>
<pre><a name="NWbitK-**bR-1" href="#NWDT"><dfn>&lt;<code>bitset_function</code> private&gt;=</dfn></a> <b>(<a href="#NWDQ">&lt;-U</a>)</b>
</pre><p>
<h4><a name=toc27><a name="NWDU">Inlined code: subject to change without notice</a></a></h4>
<p><pre><a name="NWbitK-**ba-1" href="#NWDU"><dfn>&lt;<code>bitset_function::topfn()</code> inlined&gt;=</dfn></a> <b>(<a href="#NWDQ">&lt;-U</a>)</b>
{
  id-&gt;clear();                  // set function to &quot;constant 1&quot; on all bits
  cs-&gt;universal();
}

</pre><pre><a name="NWbitK-**bg-1" href="#NWbitK-**bg-1"><dfn>&lt;<code>bitset_function::topfn(bitnum)</code> inlined&gt;=</dfn></a> <b>(<a href="#NWDQ">&lt;-U</a>)</b>
{
  assert_msg(bitnum &gt;= 0 &amp;&amp; bitnum &lt; hbn,
    (&quot;bitset_function::topfn - bit %d not in range %d-%d&quot;, bitnum,0,hbn));
  id-&gt;remove(bitnum);
  cs-&gt;add(bitnum);
}

</pre><pre><a name="NWbitK-**ba.2-1" href="#NWbitK-**ba.2-1"><dfn>&lt;<code>bitset_function::botfn()</code> inlined&gt;=</dfn></a> <b>(<a href="#NWDQ">&lt;-U</a>)</b>
{
  id-&gt;clear();                  // set function to &quot;constant 0&quot; on all bits
  cs-&gt;clear();
}

</pre><pre><a name="NWbitK-**bg.2-1" href="#NWbitK-**bg.2-1"><dfn>&lt;<code>bitset_function::botfn(bitnum)</code> inlined&gt;=</dfn></a> <b>(<a href="#NWDQ">&lt;-U</a>)</b>
{
  assert_msg(bitnum &gt;= 0 &amp;&amp; bitnum &lt; hbn,
     (&quot;bitset_function::botfn - bit %d not in range %d-%d&quot;, bitnum,0,hbn));
  id-&gt;remove(bitnum);
  cs-&gt;remove(bitnum);
}

</pre><pre><a name="NWbitK-**bZ.2-1" href="#NWbitK-**bZ.2-1"><dfn>&lt;<code>bitset_function::idfn()</code> inlined&gt;=</dfn></a> <b>(<a href="#NWDQ">&lt;-U</a>)</b>
{
  id-&gt;universal();              // set function to &quot;identity&quot; on all bits
  cs-&gt;clear();
}

</pre><pre><a name="NWbitK-**bf-1" href="#NWbitK-**bf-1"><dfn>&lt;<code>bitset_function::idfn(bitnum)</code> inlined&gt;=</dfn></a> <b>(<a href="#NWDQ">&lt;-U</a>)</b>
{
  assert_msg(bitnum &gt;= 0 &amp;&amp; bitnum &lt; hbn,
     (&quot;bitset_function::idfn - bit %d not in range %d-%d&quot;, bitnum,0,hbn));
  id-&gt;add(bitnum);
  cs-&gt;remove(bitnum);
}

</pre><pre><a name="NWbitK-**bh-1" href="#NWbitK-**bh-1"><dfn>&lt;<code>bitset_function::apply(updated)</code> inlined&gt;=</dfn></a> <b>(<a href="#NWDQ">&lt;-U</a>)</b>
{
  *updated *= *id;              // if identity function, keep bits
  *updated += *cs;              // set bits by const fns
                                // requires representation invariant
                                // that (cs == cs - id)
}

</pre><pre><a name="NWbitK-**bf.2-1" href="#NWbitK-**bf.2-1"><dfn>&lt;<code>bitset_function::compose(old)</code> inlined&gt;=</dfn></a> <b>(<a href="#NWDQ">&lt;-U</a>)</b>
{
  bit_set tmp(0,hbn);           // temporary bit set in scope
  tmp = *id;
  tmp *= *(old-&gt;cs);
  *cs += tmp;
  *id *= *(old-&gt;id);
}
</pre><p><!--def-->

<a name="NWDV">*</a>
<h2><a name=toc28>Connecting to the DFA Library</a></h2>
<a name="secConnecting"><b>[*]</b></a>
<p>
<a name="NWDW">File </a><code>dfa.h</code> is the only header file that a client module needs to
include.  The name of the library archive is <code>libdfa.h</code>, so add a
<code>-ldfa</code> switch to those seen by the linker.  This may need to appear
early in the list of library switches.  For example, a pass may make no use
of hash tables, but may need the operand bit manager, which does use
hashing.  In that case, <code>-ldfa</code> must precede <code>-lsuif1</code>, since
<code>libsuif1.a</code> provides the hash table module.
<p>
<pre><a name="NWdfa8-dfa5-1" href="#NWDW"><dfn>&lt;dfa.h&gt;=</dfn></a>
/*  Top-level Dataflow Analysis Header File */

<a name="NWdfa8-dfa5-1-u1" href="#NWDX"><i>&lt;SUIF copyright&gt;</i></a>

#ifndef DFA_H
#define DFA_H

/*
 *  Use a macro to include files so that they can be treated differently
 *  when compiling the library than when compiling an application.
 */

#ifdef DFALIB
#define DFAINCLFILE(F) #F
#else
#define DFAINCLFILE(F) &lt;dfa/ ## F ## &gt;
#endif

#include DFAINCLFILE(bit_vector_dfa.h)
#include DFAINCLFILE(operand_bit_manager.h)
#include   DFAINCLFILE(live_var.h)
#include     DFAINCLFILE(live_var_more.h)  /* For scheduling. To be moved. */
#include   DFAINCLFILE(unset_var.h)
#include   DFAINCLFILE(def_teller.h)
#include     DFAINCLFILE(def_catalog.h)
#include       DFAINCLFILE(reaching_def.h)
#include DFAINCLFILE(bitset_function.h)
#include  DFAINCLFILE(bit_vector_dfa_plus.h)
#include  DFAINCLFILE(live_varAD.h)
#include  DFAINCLFILE(instr_catalog.h)

#endif /* DFA_H */
</pre><p>
<a name="NWDX">All of the code is protected by the following copyright notice.</a>
<p>
<pre><a name="NWdfa8-SUIE-1" href="#NWDX"><dfn>&lt;SUIF copyright&gt;=</dfn></a> <b>(<a href="#NWD4">&lt;-U</a> <a href="#NWDD">&lt;-U</a> <a href="#NWDI">&lt;-U</a> <a href="#NWDL">U-&gt;</a> <a href="#NWDP">U-&gt;</a> <a href="#NWDR">&lt;-U</a> <a href="#NWDW">&lt;-U</a>)</b>
/*  Copyright (c) 1996,1997 The President and Fellows of Harvard University

    All rights reserved.

    This software is provided under the terms described in
    the &quot;suif_copyright.h&quot; include file. */

#include &lt;suif_copyright.h&gt;
</pre><p>
<h2><a name=toc29>Likely Extensions of the DFA Library</a></h2>
<a name="secExtensions"><b>[*]</b></a>
Our plan is to add analyzers to the DFA framework as we need them.
Our register allocator might give sharper performance if reaching
definitions were used in combination with liveness analysis, for example.
<p>

<h2><a name=toc30>Acknowledgments</a></h2>
<p>
The DFA library was designed and initially implemented by Prof. Michael
Smith, leader of the HUBE research group at Harvard.  As mentioned in
section&nbsp;<a href="#secBitVectorProblem">[&lt;-]</a>, his definition of the
<code>bit_vector_problem</code> class was influenced by work of Steve Tjiang at
Synopsys and Prof. Todd Mowry's students at the University of Toronto.
<p>
The CFG library that is now part of machine SUIF has greatly eased both the
implementation and use of the DFA library.  It was implemented by Cliff
Young, with contributions from Tony DeWitt and Gang Chen.
<p>
Gang Chen developed the initial version of the <code>operand_bit_manager</code>
class and made several suggestions that have improved the liveness
analyzer.
<p>
This work is supported by a National Science Foundation Young Investigator
award, grant no. CCR-9457779.  We also gratefully acknowledge the
generous support of this research by Advanced Micro Devices, Digital
Equipment, Hewlett-Packard, International Business Machines, and Intel.
<p>
<h2><a name=toc31>References</a></h2>
<p>
<a name="NWcite-bibdragon"><b>[1]</b></a>  A. Aho, R. Sethi, and J. Ullman. <em>Compilers:
Principles, Techniques, and Tools.</em>  Addison-Wesley, 1986.
<p>
<a name="NWcite-bibcrafting"><b>[2]</b></a>  C. Fischer and R. LeBlanc.  <em>Crafting a
Compiler.</em> Benjamin/Cummings, 1988.
<p>
<a name="NWcite-bibmuchnick"><b>[3]</b></a>  S. Muchnick. <em>Advanced Compiler Design and
Implementation.</em>  Morgan Kaufmann, 1997.
<p>
<a name="NWcite-bibmachsuif"><b>[4]</b></a>  M. Smith. <em>Extending SUIF for Machine-specific
Optimizations.</em>  The machine SUIF compiler documentation set, Harvard
University, 1996.
<p>
<a name="NWcite-bibcfg"><b>[5]</b></a>  C. Young. <em>The SUIF Control Flow Graph Library.</em>  The
machine SUIF compiler documentation set, Harvard University, 1997.
<p>


<h2><a name=toc32>Indecent Exposure</a></h2>
Here we expose the private parts of the library's interfaces, with
<a name="NWDY">minimal commentary.</a>
<p>
<h3><a name=toc33>Class <code>live_var_problem</code></a></h3>
<p>
The hidden members of <code>live_var_problem</code> are all variables.  One
holds the instruction-analyzer function passed at instance
construction.  The others are temporary bit vectors, declared as
class members to avoid repeated construction and destruction.
<p>
<pre><a name="NWdocA-**lS-1" href="#NWDY"><dfn>&lt;<code>live_var_problem</code> private&gt;=</dfn></a> <b>(<a href="#NWDE">&lt;-U</a>)</b>
instruction_def_use_f instr_def_use_fun;
bit_set *instr_def;
bit_set *instr_use;
</pre><p>

<h3><a name=toc34><a name="NWDZ">Class </a><code>unset_var_problem</code></a></h3>
<p>
The hidden members of <code>unset_var_problem</code> are identical to those for
<code>live_var_problem</code>.
<p>
<pre><a name="NWdocA-**uT-1" href="#NWDZ"><dfn>&lt;<code>unset_var_problem</code> private&gt;=</dfn></a> <b>(<a href="#NWDJ">&lt;-U</a>)</b>
instruction_def_use_f instr_def_use_fun;
bit_set *instr_def;
bit_set *instr_use;
</pre><p>

<h3><a name=toc35><a name="NWDa">Class </a><code>operand_bit_manager</code></a></h3>
<p>
The private part of <code>operand_bit_manager</code> declares the user-provided
operand filter and the next bit index to be assigned when an operand
is enrolled:
<p>
<pre><a name="NWdocA-**oV-1" href="#NWDa"><dfn>&lt;<code>operand_bit_manager</code> private&gt;=</dfn></a> <b>(<a href="#NWDM">&lt;-U</a>)</b> <b>[D<a href="#NWDb">-&gt;</a>]</b>
filter_f filter;
int next_index;
</pre><p>
<a name="NWDb">It also records two data structures for mapping operands to</a>
indices: <code>hard_map</code> handles hard registers; <code>soft_map</code> is
for virtual registers and symbols.  And one for the reverse
mapping: <code>anti_map</code> takes an index range back to the original
operand.
<p>
<pre><a name="NWdocA-**oV-2" href="#NWDa"><dfn>&lt;<code>operand_bit_manager</code> private&gt;+=</dfn></a> <b>(<a href="#NWDM">&lt;-U</a>)</b> <b>[<a href="#NWDa">&lt;-</a>D<a href="#NWDc">-&gt;</a>]</b>
hard_reg_map *hard_map;
hash_table   *soft_map;
hash_table   *anti_map;
</pre><p>
<a name="NWDc">Since the </a><code>hard_map</code> can be either user-provided or internally
generated, there is a variable, <code>hard_map_own</code>, that is null in
the former case and equal to <code>hard_map</code> in the latter.  The
class destructor applies <code>delete</code> to this member.
<p><pre><a name="NWdocA-**oV-3" href="#NWDa"><dfn>&lt;<code>operand_bit_manager</code> private&gt;+=</dfn></a> <b>(<a href="#NWDM">&lt;-U</a>)</b> <b>[<a href="#NWDb">&lt;-</a>D<a href="#NWDd">-&gt;</a>]</b>
hard_reg_map *hard_map_own;
</pre><p>
<a name="NWDd">There are also temporary hash table entries, used to avoid storage</a>
thrashing on hash table entries.
<p><pre><a name="NWdocA-**oV-4" href="#NWDa"><dfn>&lt;<code>operand_bit_manager</code> private&gt;+=</dfn></a> <b>(<a href="#NWDM">&lt;-U</a>)</b> <b>[<a href="#NWDc">&lt;-</a>D<a href="#NWDe">-&gt;</a>]</b>
hash_e *next_soft_map_e;
hash_e *next_anti_map_e;
</pre><p>
<a name="NWDe">The function members are simply subroutines of the public methods.</a>
<p><pre><a name="NWdocA-**oV-5" href="#NWDa"><dfn>&lt;<code>operand_bit_manager</code> private&gt;+=</dfn></a> <b>(<a href="#NWDM">&lt;-U</a>)</b> <b>[<a href="#NWDd">&lt;-</a>D]</b>
typedef void (bit_set::*bit_set_op)(int);
boolean insert_or_remove(operand, bit_set *, bit_set_op op);
boolean get_bit_range(operand, int *, int *, boolean);
boolean hr_bit_range(operand, int *, int *);
boolean covers_hr(bit_set *, operand);
</pre><p>

<h3><a name=toc36><a name="NWDf">Class </a><code>hard_reg_map</code></a></h3>
<p>
Internally, a <code>hard_reg_map</code> contains a counter for bit-index
assignment, a capacity value, and two arrays mapping a register
number to starting index and size-per-vector-bit, respectively.
<p><pre><a name="NWdocA-**hO-1" href="#NWDf"><dfn>&lt;<code>hard_reg_map</code> private&gt;=</dfn></a> <b>(<a href="#NWDO">&lt;-U</a>)</b>
int next_index;
int capacity;
int *indexes;
int *sizes;
</pre><p>
<a name="NWDg">Too simple not to compile inline:</a>
<p><pre><a name="NWdocA-**hN-1" href="#NWDg"><dfn>&lt;<code>hard_reg_map</code> inline&gt;=</dfn></a> <b>(<a href="#NWDO">&lt;-U</a>)</b>
inline int hard_reg_map::length() { return next_index; }
</pre><p>


<!-- Making \end{document} a chunk by itself seems necessary for use of-->
<!-- noweave -delay -x ..., even though the -x option suppresses the-->
<!-- cross-reference stuff that would supposedly be dumped here.-->
<a name="NWDh">*</a>




<ul>
<li><a href="#NWbitO-**bU-1"><i>&lt;<code>bit_set_array</code> declarations&gt;</i></a>: <a href="#NWbitO-**bU-1">D1</a>, <a href="#NWDD">U2</a>, <a href="#NWDG">D3</a>, <a href="#NWDI">U4</a>
<li><a href="#NWDT"><i>&lt;<code>bitset_function</code> private&gt;</i></a>: <a href="#NWDQ">U1</a>, <a href="#NWDT">D2</a>
<li><a href="#NWDS"><i>&lt;<code>bitset_function</code> protected&gt;</i></a>: <a href="#NWDQ">U1</a>, <a href="#NWDS">D2</a>
<li><a href="#NWbitK-**bh-1"><i>&lt;<code>bitset_function::apply(updated)</code> inlined&gt;</i></a>: <a href="#NWDQ">U1</a>, <a href="#NWbitK-**bh-1">D2</a>
<li><a href="#NWbitK-**ba.2-1"><i>&lt;<code>bitset_function::botfn()</code> inlined&gt;</i></a>: <a href="#NWDQ">U1</a>, <a href="#NWbitK-**ba.2-1">D2</a>
<li><a href="#NWbitK-**bg.2-1"><i>&lt;<code>bitset_function::botfn(bitnum)</code> inlined&gt;</i></a>: <a href="#NWDQ">U1</a>, <a href="#NWbitK-**bg.2-1">D2</a>
<li><a href="#NWbitK-**bf.2-1"><i>&lt;<code>bitset_function::compose(old)</code> inlined&gt;</i></a>: <a href="#NWDQ">U1</a>, <a href="#NWbitK-**bf.2-1">D2</a>
<li><a href="#NWDR"><i>&lt;bitset_function.h&gt;</i></a>: <a href="#NWDR">D1</a>
<li><a href="#NWbitK-**bZ.2-1"><i>&lt;<code>bitset_function::idfn()</code> inlined&gt;</i></a>: <a href="#NWDQ">U1</a>, <a href="#NWbitK-**bZ.2-1">D2</a>
<li><a href="#NWbitK-**bf-1"><i>&lt;<code>bitset_function::idfn(bitnum)</code> inlined&gt;</i></a>: <a href="#NWDQ">U1</a>, <a href="#NWbitK-**bf-1">D2</a>
<li><a href="#NWDU"><i>&lt;<code>bitset_function::topfn()</code> inlined&gt;</i></a>: <a href="#NWDQ">U1</a>, <a href="#NWDU">D2</a>
<li><a href="#NWbitK-**bg-1"><i>&lt;<code>bitset_function::topfn(bitnum)</code> inlined&gt;</i></a>: <a href="#NWDQ">U1</a>, <a href="#NWbitK-**bg-1">D2</a>
<li><a href="#NWD4"><i>&lt;bit_vector_dfa.h&gt;</i></a>: <a href="#NWD4">D1</a>
<li><a href="#NWDD"><i>&lt;bit_vector_dfa_plus.h&gt;</i></a>: <a href="#NWDD">D1</a>
<li><a href="#NWD6"><i>&lt;<code>bit_vector_problem_plus</code> enum&gt;</i></a>: <a href="#NWD5">U1</a>, <a href="#NWD6">D2</a>, <a href="#NWD7">D3</a>, <a href="#NWD8">D4</a>, <a href="#NWD9">D5</a>, <a href="#NWDA">D6</a>
<li><a href="#NWDC"><i>&lt;<code>bit_vector_problem_plus</code> private&gt;</i></a>: <a href="#NWD5">U1</a>, <a href="#NWDC">D2</a>
<li><a href="#NWDB"><i>&lt;<code>bit_vector_problem_plus</code> protected&gt;</i></a>: <a href="#NWD5">U1</a>, <a href="#NWDB">D2</a>
<li><a href="#NWDQ"><i>&lt;class <code>bitset_function</code>&gt;</i></a>: <a href="#NWDQ">D1</a>, <a href="#NWDR">U2</a>
<li><a href="#NWD3"><i>&lt;class <code>bit_vector_problem</code>&gt;</i></a>: <a href="#NWD3">D1</a>, <a href="#NWD4">U2</a>
<li><a href="#NWD5"><i>&lt;class <code>bit_vector_problem_plus</code>&gt;</i></a>: <a href="#NWD5">D1</a>, <a href="#NWDD">U2</a>
<li><a href="#NWDO"><i>&lt;class <code>hard_reg_map</code>&gt;</i></a>: <a href="#NWDO">D1</a>, <a href="#NWDP">U2</a>
<li><a href="#NWDE"><i>&lt;class <code>live_var_problem</code>&gt;</i></a>: <a href="#NWDE">D1</a>, <a href="#NWDI">U2</a>
<li><a href="#NWDM"><i>&lt;class <code>operand_bit_manager</code>&gt;</i></a>: <a href="#NWDM">D1</a>, <a href="#NWDP">U2</a>
<li><a href="#NWDJ"><i>&lt;class <code>unset_var_problem</code>&gt;</i></a>: <a href="#NWDJ">D1</a>, <a href="#NWDL">U2</a>
<li><a href="#NWDW"><i>&lt;dfa.h&gt;</i></a>: <a href="#NWDW">D1</a>
<li><a href="#NWDF"><i>&lt;function <code>Instruction_def_use</code>&gt;</i></a>: <a href="#NWDF">D1</a>, <a href="#NWDI">U2</a>
<li><a href="#NWDg"><i>&lt;<code>hard_reg_map</code> inline&gt;</i></a>: <a href="#NWDO">U1</a>, <a href="#NWDg">D2</a>
<li><a href="#NWDf"><i>&lt;<code>hard_reg_map</code> private&gt;</i></a>: <a href="#NWDO">U1</a>, <a href="#NWDf">D2</a>
<li><a href="#NWDI"><i>&lt;live_var.h&gt;</i></a>: <a href="#NWDI">D1</a>
<li><a href="#NWDY"><i>&lt;<code>live_var_problem</code> private&gt;</i></a>: <a href="#NWDE">U1</a>, <a href="#NWDY">D2</a>
<li><a href="#NWDH"><i>&lt;<code>live_var_problem</code> protected&gt;</i></a>: <a href="#NWDE">U1</a>, <a href="#NWDH">D2</a>
<li><a href="#NWDa"><i>&lt;<code>operand_bit_manager</code> private&gt;</i></a>: <a href="#NWDM">U1</a>, <a href="#NWDa">D2</a>, <a href="#NWDb">D3</a>, <a href="#NWDc">D4</a>, <a href="#NWDd">D5</a>, <a href="#NWDe">D6</a>
<li><a href="#NWDN"><i>&lt;<code>operand_bit_manager</code> public&gt;</i></a>: <a href="#NWDM">U1</a>, <a href="#NWDN">D2</a>
<li><a href="#NWDP"><i>&lt;operand_bit_manager.h&gt;</i></a>: <a href="#NWDP">D1</a>
<li><a href="#NWDX"><i>&lt;SUIF copyright&gt;</i></a>: <a href="#NWD4">U1</a>, <a href="#NWDD">U2</a>, <a href="#NWDI">U3</a>, <a href="#NWDL">U4</a>, <a href="#NWDP">U5</a>, <a href="#NWDR">U6</a>, <a href="#NWDW">U7</a>, <a href="#NWDX">D8</a>
<li><a href="#NWDL"><i>&lt;unset_var.h&gt;</i></a>: <a href="#NWDL">D1</a>
<li><a href="#NWDZ"><i>&lt;<code>unset_var_problem</code> private&gt;</i></a>: <a href="#NWDJ">U1</a>, <a href="#NWDZ">D2</a>
<li><a href="#NWDK"><i>&lt;<code>unset_var_problem</code> protected&gt;</i></a>: <a href="#NWDJ">U1</a>, <a href="#NWDK">D2</a>
</ul>
</body></html>

